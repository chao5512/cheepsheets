#+OPTIONS: num:nil
#+OPTIONS: toc:nil slide-header:nil org-reveal-title-slide:nil
#+REVEAL_MAX_SCALE:1.5
* NNAnalytics
一个NNAnalytics实例是一个改装过的Standby Namenode。
*** 1.孤立的，唯一与集群的交互是向集群fetch fsiamge和edits;
*** 2.只读的，end-user只能定制自己的观测需求，不能更改FSnamesystem实例;
*** 3.不提供RPC服务;
*** 4.提供web服务和一个query engine。
* 初始化
1.启动webserver
2.load FSnamesystem
#+BEGIN_SRC java
  //nna.historical打开嵌入式数据库
  nameNodeLoader.initHistoryRecorder(hsqlDriver, conf, conf.getHistoricalEnabled());
  //下载fsimage并load inodes
  //FSNamesystem.loadFromDisk(conf)
  //加载fsnamesystem后填充3种inode缓存
  nameNodeLoader.load(inodes, preloadedHadoopConf, conf);
  //初始化后台线程
  //suggestionsEngine.reloadSuggestions
  //默认15分钟reload一次
  //这个方法拿到两种inode集合，填充MapDB
  nameNodeLoader.initReloadThreads(internalService, conf);

#+END_SRC

* 主要的成员
#+BEGIN_SRC java
    private final NameNodeLoader nameNodeLoader = new NameNodeLoader();
    //数据库连接驱动
    private final HsqlDriver hsqlDriver = new HsqlDriver();
    //download and parse the fsimage
    private final TransferFsImageWrapper transferFsImage = new TransferFsImageWrapper(nameNodeLoader);
#+END_SRC

** NamenodeLoader
#+BEGIN_SRC java
  //构造
    public NameNodeLoader() {
        //目录树，可以通过set填充
        versionLoader = new VersionContext();
        //重要方法是reloadSuggestions()，作用：分析namesystem并更新内存中的报告
        suggestionsEngine = new SuggestionsEngine();
    }

  //inode的三种缓存形式
  private Collection<INode> all = null;
  private Map<INode, INodeWithAdditionalFields> files = null;
  private Map<INode, INodeWithAdditionalFields> dirs = null;
#+END_SRC

** SuggestionsEngine
#+BEGIN_SRC java
  //MapDB的一层封装
  private final CacheManager cacheManager;
  //指标名称到-值的映射
  private Map<String, Long> cachedValues;
  //指标-user-值
  private Map<String, Map<String, Long>> cachedMaps;
  private Map<String, Long> cachedLogins;
  private Set<String> cachedUsers;
  //订阅目录
  private Set<String> cachedDirs;
  //用户-目录-配额
  private Map<String, Map<String, Long>> cachedUserNsQuotas;
  //DS dir consumed
  private Map<String, Map<String, Long>> cachedUserDsQuotas;
#+END_SRC
** reloadSuggestions
#+BEGIN_SRC java
  //已知条件
  Collection<INode> files = nameNodeLoader.getINodeSet("files");
  Collection<INode> dirs = nameNodeLoader.getINodeSet("dirs");

  //填充缓存map
  cachedValues.put("diskspace", diskspace);
  cachedMaps.put("diskspaceUsers", diskspaceUsers);

  //按查询条件出fuction
  //使用JavaCollectionQEngine或JavaStreamQueryEngine
  //对inode集合应用function，比如sum
  final long diskspace = queryEngine.sum(files, "diskspaceConsumed");
#+END_SRC
* 数据库里存的指标
#+BEGIN_SRC java
  String sqlCreate =
          "CREATE CACHED TABLE IF NOT EXISTS HISTORY"
              + "  (ID BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1) "
              + "   NOT NULL PRIMARY KEY,"
              + "   STDATE TIMESTAMP NOT NULL,"
              + "   SYS_DATE DATE NOT NULL,"
              + "   EMPTYDIRS BIGINT,"
              + "   TINYFILES BIGINT,"
              + "   EMPTYFILES BIGINT,"
              + "   SMALLFILES BIGINT,"
              + "   DISKSPACE BIGINT,"
              + "   NUMFILES BIGINT,"
              + "   NUMDIRS BIGINT,"
              + "   USER VARCHAR(100) NOT NULL)";
#+END_SRC
* webServer
** /fetchNamespace
#+BEGIN_SRC java
  //main()
  transferFsImage.downloadMostRecentImage();
  //TransferFsImageWrapper
  TransferFsImage.getFileClient(
                    infoServer, fileId, Lists.newArrayList(namespaceDir), storage, true);
#+END_SRC
** /reloadNamespace
#+BEGIN_SRC java
namenodeLoader.load();
#+END_SRC
* 问题
两个engine
inode变化是怎么检测到的，每15分钟一次，放入db
