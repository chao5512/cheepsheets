#+title: 排序
* 假设
1. 都是按从小到大排序
* 基于比较的排序算法
** 冒泡
*** 时间复杂度最坏为O(n2)
*** 稳定
*** 优化方法
1. 外层循环加全局有序判断，这样最好情况为O(n)
2. 内层循环利用局部有序，记录最后发生交换的位置，用来更新外层循环上限和内循环上限
*** 应用场景布吉岛
** 选择排序
*** 思路：
+ 从待排序列中选择一个最小元素的放在最前面
*** 具体的: 
+ 内循环将无序序列中最小的元素交换到头一个位置
+ 外层循环不断地减掉已经有序的部分
*** 不稳定的
+ B_1 B_2 A  选择排序为A B_2 B_1 
*** 时间复杂度
+ 最好 : \omicron(n)
+ 平均 : \Omicron(n^2)
*** 代码
#+BEGIN_SRC java
  public void sort(Comparable[] a) {
      for (int i = 0; i < a.length - 1; i++) {
          for (int j = i + 1; j < a.length; j++) {
              if (lessThan(a[j], a[i])) {
                  exch(a, i, j);
              }
          }
      }
  }
#+END_SRC
*** 优化
+ 思路 : 
  1. 如上面的代码，在内循环中，每次交换都使得内循环里的上一次交换回正确位置的元素远离他的正确位置
  2. 内循环是选择最小元素哎，可以用最小堆么
** 插入排序
*** 时间复杂度
+ 最好O(n)
+ 平均O(n2)
+ 最坏O(n2)

*** 稳定
*** 使用场景
1. jdk中的Arrays.sort()在排序长度小于7的时候使用直接插入
2. 在近乎有序的数据中
** 归并排序
*** 时间复杂度
O(nlogn)
*** 稳定
*** 优化手段
1. 合并阶段判有序
2. 当合并的两部分中一部分用尽，另一部分直接放入
*** 适用场景
1. 需要稳定的场景下
2. 数据结构是链表的情况下（因为快排依赖数据的随机存取，不适用于链表）

** 快速排序
*** 三大缺点
1. 最坏O(n2)
2. 平均性能O(nlogn) [[https://www.bilibili.com/video/av49361421/?p=449][证明]]
3. 不稳定
4. 不适应（原始数据越有序，快排越慢）
*** 轴点的选择
1. 不同的轴点选取算法只能降低最坏情况的可能性，而不能杜绝最坏情况
*** 适用算法
1. k-selection
2. 选取中位数
*** 引申问题
1. 选取众数
2. 选取第K大元素
3. 中位数 
*** inbox
- 相比于归并排序看中“合”，快速排序看中“分”
- 快排的可以看做将所有待排元素转换为轴点的过程
** 三路快排
*** 适用场景
数据中含有大量重复元素
** 堆排序
** 希尔排序
** 桶排序
复杂度 : \Omicron(n)
** 统计排序（计数排序）
*** 适用场景
对分数进行排序
** 基数排序
* todo
** TODO 轴点的选择<2018-09-18 二 15:42>
:LOGBOOK:
CLOCK: [2018-09-18 二 16:33]--[2018-09-18 二 16:58] =>  0:25
:END:
方案[1/3]
- [X] 打乱数组
- [ ] 随机选数
- [ ] 三元素取中 
- State "TODO"       from              [2018-09-18 二 15:42]
** 双轴快速排序
** 中位数和众数的选择
** cpu分支预测
** 内存缓存
** 归并的优化
+ 自底向上的迭代实现
** 堆排序实际使用效率不高的原因
* 稳定性的意义
- 对于基本数据类型无意义
- 对对象类型保证有序
* 排序的思路
1. 首先考虑快速排序
2. 有大量重复元素使用三路快排
3. 需要稳定或依赖随机存取使用归并
4. 数据近乎有序使用插入
5. 其他场景
   1. 能不能使用计数排序，数据有一定的取值范围
   2. 是否需要外村排序算法
