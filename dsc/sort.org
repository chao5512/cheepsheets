#+title: 排序
* 假设
1. 都是按从小到大排序
* 基于比较的排序算法
** 冒泡
*** 时间复杂度最坏为O(n2)
*** 稳定
*** 优化方法
1. 外层循环加全局有序判断，这样最好情况为O(n)
2. 内层循环利用局部有序，记录最后发生交换的位置，用来更新外层循环上限和内循环上限
*** 应用场景布吉岛
** 选择排序
*** 思路：
+ 从待排序列中选择一个最小元素的放在最前面
*** 具体的: 
+ 内循环将无序序列中最小的元素交换到头一个位置
+ 外层循环不断地减掉已经有序的部分
*** 不稳定的
+ B_1 B_2 A  选择排序为A B_2 B_1 
*** 时间复杂度
+ 最好 : \omicron(n)
+ 平均 : \Omicron(n^2)
*** 代码
#+BEGIN_SRC java
  public void sort(Comparable[] a) {
      for (int i = 0; i < a.length - 1; i++) {
          for (int j = i + 1; j < a.length; j++) {
              if (lessThan(a[j], a[i])) {
                  exch(a, i, j);
              }
          }
      }
  }
#+END_SRC
*** 优化
+ 思路 : 
  1. 如上面的代码，在内循环中，每次交换都使得内循环里的上一次交换回正确位置的元素远离他的正确位置
  2. 内循环是选择最小元素哎，可以用最小堆么
** 插入排序
*** 时间复杂度
+ 最好O(n)
+ 平均O(n2)
+ 最坏O(n2)
*** 稳定：在插入条件为不大于(不是小于)插入元素时。
具体看代码
*** 使用场景
1. jdk中的Arrays.sort()在排序长度小于7的时候使用直接插入
2. 在近乎有序的数据中，可以用范围很小的有大量重复元素的数据模拟
*** 代码
#+BEGIN_SRC java
    public void sort(Comparable[] a) {
        //整理出lo hi
        int hi = a.length;
        for (int i = 1; i < hi; i++) {
            int j=i-1;
            //保存需要插入的元素
            Comparable t = a[i];
            //从后向前遍历有序队列，直到找到第一个小于插入元素的元素的位置
            //此位置右边整体向右移动一位，把插入元素插入这个位置之后
            //这里需要注意判定条件，在之前为lessThan(t,a[j])，这样就会丢失稳定性，甚至还有性能的损失
            while (j>=0&&lessThan(t,a[j])){
                a[j+1]=a[j];
                j--;
            }
            //找到的位置就是前一个位置，避免自我赋值
            if(j!=i-1){
                a[j+1]=t;
            }
        }
    }
#+END_SRC
** 归并排序
*** 时间复杂度
+ 层级为\Omicron(\log N )
+ 每层为\Omicron(N)
+ 所以时间复杂度为O(nlogn)
*** 稳定
与插入排序一样，稳定性都是与代码相关的，正确的代码保证稳定性
*** 优化手段
1. 合并阶段判有序
2. 当合并的两部分中一部分用尽，另一部分直接放入
*** 适用场景
1. 需要稳定的场景下
2. 数据结构是链表的情况下（因为快排依赖数据的随机存取，不适用于链表）
*** 缺点
+ 需要额外的辅助空间
*** 自顶向下的code
#+BEGIN_SRC java
  private void sort(Comparable[] a,Comparable[]aux, int lo, int hi) {
      if (lo >= hi) {
          return;
      }
      //不使用(lo+hi)/2这种形式找中点的原因之一是下面这样不会发生（lo+hi）溢出的错误
      int mid = lo + ((hi - lo)>>>1);
      sort(a,aux ,lo, mid);
      sort(a,aux ,mid + 1, hi);
      merge(a,aux, lo, mid, hi);
  }
  private void merge(Comparable[] a,Comparable[] aux, int lo, int mid, int hi) {
      assert isSorted(a, lo, mid);
      assert isSorted(a, mid + 1, hi);
      //如果已经有序了，直接返回原数组,递归基
      if(lessThanOrEqual(a[mid],a[mid+1]))return;
      //
      for (int i = lo; i <= hi; i++) {
          aux[i] = a[i];
      }
      //分成p,q前后两个数组。
      for(int i = lo, p = lo, q = mid+1; i <= hi; i++) {
          //第三个条件正常的形式应该是lessOrEqual(aux[p],aux[q]),或者整个改成后面数组在成立条件里，怎么办都行。
          if (q > hi || p < mid+1 && !lessThan(aux[q],aux[p]))
              //p归队的情况
              //1. q > hi q数组已经为空
              //2. 或者在p不为空（p<mid+1）的前提下，p的首元素小于等于(等于这个条件是为了稳定性)q的寿元素
              a[i] = aux[p++];
          else
              //其他情况全是q
              a[i] = aux[q++];
      }
  }
#+END_SRC
*** 自底向上的code
#+BEGIN_SRC java

#+END_SRC
*** 比较
+ 以上两种实现方式效率上差不多，统计意义上，递归还要比迭代快。
+ 自底向上的排序没有使用数组的秩
+ 可以用自底向上的排序来实现链表的n\Omicron(\log N)的排序
** 快速排序
*** 三大缺点
1. 最坏O(n2)
2. 平均性能O(nlogn) [[https://www.bilibili.com/video/av49361421/?p=449][证明]]
3. 不稳定
4. 不适应（原始数据越有序，快排越慢）
*** 轴点的选择
1. 不同的轴点选取算法只能降低最坏情况的可能性，而不能杜绝最坏情况
*** 适用算法
1. k-selection
2. 选取中位数
*** 引申问题
1. 选取众数
2. 选取第K大元素
3. 中位数 
*** inbox
- 相比于归并排序看中“合”，快速排序看中“分”
- 快排的可以看做将所有待排元素转换为轴点的过程
** 三路快排
*** 适用场景
数据中含有大量重复元素
** 堆排序
** 希尔排序
** 桶排序
复杂度 : \Omicron(n)
** 统计排序（计数排序）
*** 适用场景
对分数进行排序
** 基数排序
* todo
** TODO 轴点的选择<2018-09-18 二 15:42>
:LOGBOOK:
CLOCK: [2018-09-18 二 16:33]--[2018-09-18 二 16:58] =>  0:25
:END:
方案[1/3]
- [X] 打乱数组
- [ ] 随机选数
- [ ] 三元素取中 
- State "TODO"       from              [2018-09-18 二 15:42]
** 双轴快速排序
** 中位数和众数的选择
** cpu分支预测
** 内存缓存
** 归并的优化
+ 自底向上的迭代实现
** 堆排序实际使用效率不高的原因
* 稳定性的意义
- 对于基本数据类型无意义
- 对对象类型保证有序
* 排序的思路
1. 首先考虑快速排序
2. 有大量重复元素使用三路快排
3. 需要稳定或依赖随机存取使用归并
4. 数据近乎有序使用插入
5. 其他场景
   1. 能不能使用计数排序，数据有一定的取值范围
   2. 是否需要外村排序算法
