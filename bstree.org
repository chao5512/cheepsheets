* binary search tree
** TODO 考察树高的平均情况 P18
   1. 随机生成 logn
   2。随机组成 根号n
** 平衡=》最小树高
   1. 等价bst的特性
      上下可变
      左右不乱
   2. 等价bst之间的转换
      zig 右旋
      zag 左旋
   3. AVL树
** Application of binaryTree to Compiler
** 二叉查找树是TreeMap和TreeSet的基础

* avl树
* 伸展树
** 数据局部性原理
伸展树想要利用局部性原理
1. 刚刚被访问的元素可能马上要被访问
2. 刚刚被访问的元素的周边元素可能马上要被访问
** 退化
一步一步往上爬到顶会退化到omega n
** 改进：回溯两层的四种情况（考察的是祖孙三代）
zig-zig(重)祖父节点先旋转
zag-zig(重)
上面两种会路径减半 nice
zig-zag
zag-zag
当祖父节点为空时，父节点即是root
** 分摊意义下：单趟伸展的复杂度为logn
** serch接口查找失败的时候也要把最接近目标的元素伸展到root
利用了局部性原理第二条
** insert接口把目标元素作为树根。把老树根（一定为目标元素的直接前驱）和其左子树作为目标元素的左子树
** remove把root的直接后继作为新root
** 性能（更为灵活）
分摊效果很好logn
单次最坏不能避免
* B-树（平衡多路搜索树）
SCHEDULED: <2018-09-19 三 16:50>
** 目标：实现高效的io，即解决不同存储结构的素的差异
640k
封闭分析 10的5次方
内外存操作次数大致相当
** 存储器差异的两个事实
1. 内存一秒，硬盘一天 10的5次方
2. 从硬盘读1b和1k的速度差不多（因为使用批量（page）来传输数据）
** B-树的性质 
所有叶节点的深度相等
** 超级节点（m阶=n+1）
节点大小与外存页面（page）大小相等
两个数组
1. n个关键码组成的数组
2. n+1个引用组成的数组
长度为几百的数组，二分查找反而没有顺序查找的效率高
** 复杂度
m阶B-树的查找复杂度上界是logmN
m阶B-树的查找复杂度下界是logmN
** 维护m阶结构
*** 没办法避免--上溢--》分裂
插入树长高的唯一方式
树长高发生在顶部
插入一定是插在叶节点上
trick:插入的search阶段可以直接检测中间节点是否为满节点,满节点直接分裂。
*** 保证树饱满--下溢--》旋转+合并
trick:在实际场景中，由于一颗b树的大部分关键字都在叶节点中，所以删除一般都会命中叶节点
** B-树的应用场景
mysql的两种存储引擎

* B+树
*** 三种存储引擎
1.hash存储引擎
- 支持随机读写的Mr.Right
2.B树存储引擎
- 支持顺序和随机读写，mysql
3.LSM树存储引擎
- 比B树存储引擎高在将随机写转化为顺序写(imp by batch),写入效率高
— 但是因为数据不及时落盘，目标数据可能存在多个部件中
- 同时也因为只追加的缘故，目标数据可能在多个磁盘文件上
- 比如：在hbase中，在一个region上的数据写入，如果我们忽略列存的事实，即便数据按行存，同一行也可能会存在多个磁盘文件中

1. 中间节点只存放关键字和孩子指针，最大化了分支数，也就是logn的底数

* 红黑树
** 不要遗忘历史
1. ephemeral结构
2. persisten结构
** 我们需要一种不论是insert还是remove的重构操作数都是常数O(1)==红黑树！！
nice！！
** 红黑树的规则
1. 黑帽子
2. 黑靴子（只是假想的，trick）
3. 红节点的父节点和子节点比为黑色
4. 黑深度满足平衡定义
** 解决双红缺陷
提升变换
** 解决删除时的双黑缺陷
** 可以说听得一头雾水
红黑树和2-4树的强关联
* succ、zag、zig、邓俊辉=》计算几何=》bbst的历史版本
* 树
** 树的表示
*** 树的约定术语
| 英文            | 翻译   |
|-----------------+--------|
| degree          | 度     |
| root            | 根     |
| edge            | 边     |
| node            | 顶点   |
| child           | 孩子   |
| parent          | 父亲   |
| silblings       | 兄弟   |
| leaf            | 叶子   |
| grandparents    | 祖父   |
| depth           | 深度   |
| height          | 高度   |
| ancestor        | 祖先   |
| proper ancestor | 真祖先 |
|                 |        |
*** inbox
- RPN与树的关系
- 树中顶点数与边数同阶
- 长子兄弟表示发法的优点，每个节点所需的存储空间大致相当，相对于父亲孩子表示法，查找孩子时的耗费更加平均
** 二叉树
*** 概念
1. 所有顶点的出度不超过2的树是一颗二叉树
2. 在保障有根性和有序性的前提下，用长子兄弟表示法可以把任意一棵树表示为二叉树
*** 二叉树的实现
**** inbox
1. getsize()、getHeight（）、getDepth（）递归实现，递归计算左子树加右子树
2. java中的迭代器完成了C++中的函数指针的便利性
3. 树的前序、后序、层次遍历均可在O(n)时间内完成
4. jdk中怎么实现迭代器的。不能再接一个list吧。空间有点太浪费了
**** 遍历
***** 定义
- 已知中序 * [先序或者后序] = 重构二叉树
- 已知真二叉树 * [先序或者后] = 重构二叉树 
| 先序                                    | 中序                     | 后序              |
|-----------------------------------------+--------------------------+-------------------|
| v \rArr l \rArr r                       | l \rArr v \rArr r        | l \rArr r \rArr v |
| 中左右                                  | 左中右                   | 左右中            |
| 用栈迭代替代尾递归                      | 迭代遍历，线性时间复杂度 |                   |
| 迭代进化 : 栈只存右孩子，包括空的右孩子 |                          |                   |

***** 广度优先遍历
- 使用队列辅助实现
***** 深度优先遍历
*** 二叉树的应用
1. expression tree : inorder travelsal
2. PFC frefix-free code : 是一种在线算法，可以再接受二进制的同时进行解码
*** inbox
- 设二叉树的高度为h，name二叉树的节点数n的取值范围为 : h < n < 2^(h+1)
- 满树
- 真二叉树 : 所有顶点出度为2或者0
** 完全二叉树 
*** 向量实现的完全二叉树
*** 定理：在完全二叉树的向量实现中，root节点对的秩为0，则秩为i的节点
    1. 若存在左孩子，左孩子的秩为 2i+1
    2. 若存在右孩子，则右孩子的秩为2i+2
    3. 若存在父节点，则父节点的秩为（i-1)/2
