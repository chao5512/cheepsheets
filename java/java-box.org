#+title: java复习
* javac
1. -d 递归生成包指定的目录
2. import导入一个包的时候，并不会把子包一并导入
* String
** 三种类型
+ String 内部是一个final修饰的数组，是常量，创建后值将不能再被改变
  + String类型的变量的赋值，如果使用字面量赋值，那么jvm会现在常量池中找这个字面量对应的String对象，存在则直接指向
  + 如果使用new方式赋值，会在堆上创建对象，并保证在常量池中也存该字面量对应的一个对象
+ StringBuilder 普通数组，实现了扩容策略，允许追加
+ StringBuffer 与StringBuilder相同，当时append方法加了锁，是线程安全的
** intern
+ “xxx”.intern()，如果字符串池中已经有与xxx equal()的值得时候，直接返回字符串池中的对象，如果没有，则在池中创建一个
* hash
+ hashcode 一个对象的标识，用来配合hash表使用
+ 常与equal一起重写
* Integer
+ 如果想使用一个Integer的实例，相比于构造方法，应优先使用valueOf方法，因为valueOf方法缓存了-128~127之间的Integer实例
* Long
** parseLong 和 valueOf的区别
1. parseLong将格式正确的字符串转换成10radix的long
2. valueOf 第一步调用parseLong得到long，然后自动装箱成Long，这里用一个静态内部类LongCache缓存了-128 -- 127 的Long型a对象
3. 有时候valueOf后面的自动装箱是多余的，使用的时候可以留心
* 枚举
+ values()和valueOf()
+ 我们定义的枚举类型都是继承自java.lang.Enum类
+ 枚举类中的成员变量都是public static
+ 每个枚举的成员本质上就是枚举类型的一个实例，在编译时就确定下来的，运行时无法新添加了
+ [[https://blog.csdn.net/qq_21870555/article/details/82769721][使用枚举类型来代替你的常量们]]
* 反射
** Class
1. Class.getMethods（） 获取的时所有 *pulbic* 方法
2. 通过反射访问私有成员方法，应该用instance.getClass().getDeclaredMethods和Method#setAccessible(true);
* Annotation
帮助尽早发现bug

** build-in annotation
*** java.lang
+ @Override     保持策略为source
  - 吩咐compiler检查这个方法是不是重写的继承方法，如果不是编译报错
  - 一个作用是，当你的本意是想重写一个父类方法时，不小心弄错了一些符号或者参数或者什么东西，这些失误会导致compiler曲解你的意思，它以为你要生命一个新的方法，这显然是不对的。此时如果你给自己规定所有重写父类的方法都做一个maker，让编译器有能力明白的你的意思，并帮你做一些检查，这个maker就是@Override
+ @Deprecated            保持策略为
  - 过期方法，编译时警告
+ @Suppresswarnings("unchecked")      保持策略为source
  - 在编译的时候不标记范围内（如function）中的警告会被镇压
*** java.lang.annotation - Meta annotation
配置其他注解的注解
+ @interface 注解的类型
+ @retention 可以通过retention来设定注解的生命周期，保持到什么时候
  + source
  + class
  + runtime 通过反射
+ @Target   限定其他注解作用范围(一个java 元素)
+ @Documented  自定义注解时，生成java doc的同时，附加注解的帮助文档
+ @Inherited    默认情况下，一个父类的注解不会被继承到子类，可以在配置注解时使用@Inherited来让子类继承配置的注解
*** java 7 之后
@SafeVarargs
*** java 8 之后
1. @FunctionalInterface 声明为一个函数接口
2. @Repeatable 同一个注解声明可以使用多次
*** 自定义注解
**** 注解声明和使用
#+BEGIN_SRC java
    // @Twizzle is an annotation to method toggle().
    @Twizzle
    public void toggle() {
    }

    // Declares the annotation Twizzle.
    public @interface Twizzle {
    }
#+END_SRC
**** 注解可以一些可选的kv  for what?

#+BEGIN_SRC java
    // Same as: @Edible(value = true)
    @Edible(true)
    Item item = new Carrot();

    public @interface Edible {
        boolean value() default false;
    }

    @Author(first = "Oompah", last = "Loompah")
    Book book = new Book();

    public @interface Author {
        String first();
        String last();
    }
#+END_SRC
**** 可配置的作用范围和使用时机
#+BEGIN_SRC java
    @Retention(RetentionPolicy.RUNTIME) // Make this annotation accessible at runtime via reflection.
    @Target({ElementType.METHOD})       // This annotation can only be applied to class methods.
    public @interface Tweezable {
    }
#+END_SRC
**** 保留的注解
为了向compiler明确语义
**** TODO 使用场景
参考 [[https://en.wikipedia.org/wiki/Java_annotation#cite_note-3][wiki]]
* junit
** 版本
1. 3.8 ：基于反射
2. 4+ ：基于注解和反射
** JUnit4的执行的一般流程:
1. 首先获得待测试类所对应的cass对象。
2. 然后通过该Cass对象获得当前类中所有 public方法所对应的 Method数组
3. 遍历该 Method数组,取得每一个 Method对象
4. 调用每个 Method对象的 isAnnotation Present(Test class)方法,判断该方法是否被Test注解所修饰。
5. 如果该方法返回true,那么调用 method. invoke方法去执行该方法,否则不执行。
** 测试用工具类Optional

* Throwable
* Exception
** 分类
1. Checked exception
2. Unchecked exception
** Error
内存溢出属于Error，所以只捕获Exception是捕获不到的
* 深拷贝和浅拷贝
1. 这里的拷贝是对对象的拷贝，所以就设计对象本身和对象引用的对象
   1. 深拷贝，对象本身和所有引用的对象都复制
   2. 浅拷贝，只复制对象本身
2. 继承自Object.clone的复制都是浅拷贝
* 内部类
定义在内部类
** 分类
1. 静态内部类，只能访问外部类的静态方法和静态属性
2. 成员内部类，创建方式，new 外部类 .new 内部类;
3. 局部内部类，定义在方法中的，只能访问方法中的final类型的变量
4. 匿名内部类，
** 逆命内部类的参数引用为什么是final？
[[https://blog.nekolr.com/2018/05/29/%25E4%25B8%25BA%25E4%25BD%2595%25E5%258C%25BF%25E5%2590%258D%25E5%2586%2585%25E9%2583%25A8%25E7%25B1%25BB%25E7%259A%2584%25E5%258F%2582%25E6%2595%25B0%25E5%25BC%2595%25E7%2594%25A8%25E8%25A6%2581%25E7%2594%25A8%2520final%2520%25E4%25BF%25AE%25E9%25A5%25B0/][Ref]]
1. java的参数传递是值传递，也就是参数在接到的时候就是原值的一个副本。引用传递也是传递的引用的副本，指向同一个对象罢了
2. 因为 Java 只实现了值捕获，所以匿名内部类中使用的自由变量是原来的自由变量值的一个副本（基本类型是值的副本，引用类型是引用地址值的副本），修改它们的值并不会影响外部环境中的自由变量，为了让使用者使用起来感觉和引用捕获一样，Java 干脆做了限制：在 JDK 8 以前，必须使用 final 修饰，在 JDK 8 以后，可以不用 final 修饰，但是变量必须是有效只读的，即 effectively final 的。这样大家一看是 final 的，就不会去修改它了，即便修改也会编译器报错。即使以后 Java 实现了引用捕获，也不会和已有的代码发生不兼容。
** inbox
1. 在内部类中访问外围类的属性，Outclass.this.属性
* jdk1.8
** 包 
+ java.util.function

** lambda
*** 函数式接口
+ 整一个只有一个method的接口，用来“传method"
+ 在一个接口上加上注解@FunctionalInterface时，编译器帮我们检查该接口是否符合函数式接口
+ 一个满足函数式接口定义的接口，编译器也还是会把接口看做一个函数式接口
**** lambda表达式和方法引用
如果 lambda 表达式的目的仅是将一个形参传递给实例方法，那么可以将它替换为实例上的方法引用。如果传递表达式要传递给静态方法，可以将它替换为类上的方法引用。
#+BEGIN_SRC java
  // lambda
  .map(e -> System.out.println(e))；
   // 方法引用
      .map(System::out)
    
#+END_SRC
*** 级联lambda
返回函数的函数即为级联lambda表达式
*** 与闭包的比较
[[https://developer.ibm.com/zh/articles/j-java8idioms10/][Ref]]k
** 接口中的默认方法
** joda-time
+ 不可变对象
+ 标准UTC时间:2014-11-04T09:22:54.876Z
+ 传输按上面的形式来传，没有歧义
** 静态推导（类型推断）
java8是java第一个支持类型推断的版本
** Optional
1. 针对空指针异常，即当你明确带访问的对象中是非null的，使用Optional避免无意义的空指针异常
2. orElseGet(supplier) ,如果supplier提供了值作为备用值 
** Stream
*** 概念
1. 一个源+ Optional中间操作+终止操作
2. 操作分类
   1. lazy 求值
   2. 及早求值
** Functional interface
*** 三条法则
1. 一个函数接口只有一个抽象方法，任何满足单一抽象方法的接口都会被是做函数接口
2. 在 Object 类中属于公共方法的抽象方法不会被视为单一抽象方法。
3. 函数接口可以有默认方法和静态方法。
*** 四种基本形式
1. Function T到R的一元函数
2. Consumer T到void的一元函数
3. Predicat T到boolean的一元函数
4. Supplier nil到R的无参函数
*** 参数个数（arity）前缀
加前缀Bi将为二元函数
*** 衍生形式
1. UnaryOperator 一元操作符，参数与返回值类型相同
2. BinaryOperator 二院操作符，参数与返回值类型相同
*** 前缀ToXxx，表示返回值类型
1. ToIntFunction
*** 形参前缀
1. DoubleConsumer
2. ObjIntConsumer
*** 参数To返回值前缀
IntToDoubleFunction
*** 如果所有参数到显示的指定类型，那么arity前缀是多余的
*** 内置函数接口Functional
**** Function
1. 用于map()
**** Predicate
1. 用于filter()
**** consumer
1. 实现accept方法，消费接到的值
2. 用于forEach
**** supplier
实现get方法，提供值。例如：用与给Optional提供值
*** 自定义函数接口
1. 使用 @FunctionalInterface 注释该接口，这是 Java 8 对自定义函数接口的约定。
2. 确保该接口只有一个抽象方法。
** time
1. time 包中参照ISO标准定义了一些时间相关的类,都是不可变、线程安全的
2. 所有的date time都是由暴露创建接口的字段们组成，如果想要直接访问字段，查阅子包temporal中的
3. 各个时间表示直接的转换参照子包format
4. 子包chrono包含了calender的api
5. 推荐的做法是持久化时间、如像数据库和网络传输的时候使用iso-8601标准，由使用层来转换
*** dates and times
**** Instant
时间戳/时间点，可以从clock中获取
**** LocalDate
存一个日期，没得具体时间
**** LocalTime
只有时间，没得日期
**** LocalDateTime
形如2010-12-03T11:30
**** ZonedDateTime
附带时区的完整时间，建议尽量用默认时区，以减少复杂性。但是为了做日志分析，我还是全都加上了时区。
*** Duration and Period
**** Duration 相对于时间点，可以贝当作为时间线
**** Period
*** 附加的value类型
**** OffsetTime 和OffsetDateTime主要用于网络传输和存数据库，因为相比Europe/Paris，+02:00 是更为简单的结构
* ForkJoin框架
**  ForkJoinPool
+ 与其他Executor Service相比，ForkJoinPool的优势在于，pool中的线程除了处理提交上来的任务外，还会处理pool中其他线程产生的子任务。
*** 适用于
1. 有很多小任务
   1. 会产生许多小任务
*** asyncMode
在构造中设置asyncMode为true，意味着pool适用于基于事件不用去join的task
** ForkJoinTask
一个ForkJoinTask类似于线程，但是比线程更轻量，是一个轻量的Future
* java中的设计模式
** 单例模式
** 策略模式
+ 抽象策略角色：Comparable
+ 具体策略角色： 具体的Compartor
+ 环境角色 : Collections,TreeMap
** 代理模式
*** 角色
+ 共同的能力(接口)
+ 代理角色，持有真实角色的引用
+ 真实角色
*** hbase中的协处理器使用到代理模式
*** 静态代理
真实对象是实现存在的
*** 动态代理
+ 一个接口 ：invocationHandler
+ 一个类 : Proxy 动态代理类
+ 范式，使用Proxy.newProxyInstance(谁,干什么,handler(怎么干))来动态生成一个代理类，然后调用代理被托管的那个真实角色的方法，同静态方法。
** 装饰模式(wapper)
+ 包装一个对象，使其功能变多，且上层感觉不到
+ 在不创建更多类的情况下扩展对象功能
*** 角色
1. component --> InputStream
2. concrete component -->FileInputStream
3. decorator --> FilterInputStream
4. concrete decorator --> BufferedInputStream
* native
java中怎么调用c++
* 网络编程 
** 阻塞IO的一般步骤
1. 服务端
#+BEGIN_SRC java

  //阻塞io的服务器步骤
  ServerSocket serverSocket = new ServerSorcket();
  serverSocket.bind(8899);
  while(true){
      Socket socket = serverSocket.accept();//阻塞方法
      new Thread((socket)->{
              System.out.printf(“do somthing here”)
                  socket.getInputStream();
      }).start;
  }
#+END_SRC
2. 客户端
#+BEGIN_SRC java
  //port 是用来与服务器建立连接的端口
  int port = 8899;
  Socket socket = new Socket( "localhost",port);
  socket.connect();
#+END_SRC
* 文件io
[[https://www.cnkirito.moe/file-io-best-practise/][徐婧峰@ali]]
** java中的io分类
*** 1. io
位于java.io, 普通io
**** 核心是流
***** 分类
****** 按功能
1. 输入流
2. 输出流
****** 按结构
1. 字节流
   1. InputStream
   2. OutputStream
2. 字符流
   1. Writer
   2. Reader
****** 按继承关系
1. 节点流：直接连设备
2. 过滤流：另外一个流的包装，使用的是装饰模式
***** 流是单向的
**** 使用步骤(面向流的编程)
1. 打开一个流
2. (optional:组合功能到一个流链)
3. 循环从/向流中读/写数据
4. 关闭流
*** 2. nio
java.nio,不全都是非阻塞io，fileChanel就可以阻塞
**** 核心
1. Selector：一个线程根据事件来选择不同的Channel
2. Channel
   1. 只能通过Buffer来读写
   2. 双向的（linux底层也是双向的）
3. Buffer
   1. 原生数据类型(除了Boolean)都有自己的Buffer
**** 通信过程

#+DOWNLOADED: https://img-blog.csdn.net/20141213161210309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9iaW5qd29uZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center @ 2019-12-04 17:59:48
[[file:nio/2019-12-04_17-59-48_20141213161210309.png]]

**** Buffer
+ 是一个特殊原生类型的容器。
+ buffer不能断点续读
+ 不是线程安全的
+ byteBuffer可以存其他各种原生类型
***** 重要属性
1. capacity ： buffer的容量
2. limit ：读到哪，buffer中第一个不能被读写的位置
3. position ： buffer中下次用于读写的位置
***** slice方法
返回一个buffer的子序列为新的buffer，底层共享同一份数组，但是有4个独立的标志位
***** DirectBuffer
+ 使用Unsafe来分配内存，读写内存。每个DirectBuffer有一个自己的回收器DeAllocator
+ Buffer中有一个表示堆外内存地址的long型address
+ 因为这个buffer是要和硬件打交道的，所以直接分配到操作系统内存中，省掉了一步从堆copy到系统内存。即零拷贝。更快
***** MappedByteBuffer
+ 映射文件的内存。这不是emacs的buffer？
+ 把文件的某一部分缓存到内存中，可以直接在内存中写，由操作系统决定怎么写回文件。
***** 文件锁
fileLock
***** scattering
比如，从文件中读到多个buffer。天然的适配解析具有一定格式的数据
***** Gathering
比如, 从多个buffer向一个文件写
***** ByteBuffer
用来提供底层存储(数组)的一种视图,来方便读写内容,but how?
****** 使用实例
******* 两种创建方式
1. wrap一个已经存在的byte[] 作为ByteBuffer
2. allocate指定大小的ByteBuffer
#+BEGIN_SRC java
  // 写
  byte[] data = new byte[4096];
  long position = 1024L;
  // 指定 position 写入 4kb 的数据
  fileChannel.write(ByteBuffer.wrap(data), position);
  // 从当前文件指针的位置写入 4kb 的数据
  fileChannel.write(ByteBuffer.wrap(data));

  // 读
  ByteBuffer buffer = ByteBuffer.allocate(4096);
  long position = 1024L;
  // 指定 position 读取 4kb 的数据
  fileChannel.read(buffer,position)；
  // 从当前文件指针的位置读取 4kb 的数据
  fileChannel.read(buffer);
#+END_SRC
******* 按底层存储分类
******** 1. 直接内存
使用allocateDirecct或者map创建
******** 2。非直接内存
******* 如何转换成array
自带array方法,但此方法放回的是底层存储的引用,所以如果想得到数组的副本,使用这作为上层,自己实现
1. 使用duplicate
2. 使用Arrays.copyOf()
******* 基操
1. clear : limit = capacity; position = 0; 初始化
2. put :
3. flip : limit = position; position = 0;
4. get :
5. rewind : position = 0; 读之后再读一遍


****** 和byte array的区别
1. Bytebuffer相较于ByteArray,他的hashcode()/equal()是有意义的,只要两个ByteBuffer在position和limit之间的byte[]值是相等的,ByteBuffer就是相等的
2. 在获取子集场景下,ByteBuffer提供了一种零拷贝的方式,也就是只创建新的ByteBuffer实例而不是底层存储的拷贝.
3. ByteBuffer拥有堆外实现
4. ByteBuffer提供一些字节数组之上的附加状态,这使得通过ByteBuffer更容易进行相对位置IO操作
5. 提供了各种原始类型的IO操作
******* 总结
相较于Byte Array, NIO更需要一种高效率(获取子集时零拷贝),可以更方便的使用相对位置进行Byte Array 读写操作的数据结构-ByteBuffer
****** 关键属性
1. capacity 不变
2. limit 读写的边界
3. position 读或写的起点.显然ByteBuffer只能处于读或写一种状态
***** Netty ByteBuf
网络传输的最小单位是byte
****** 为什么不用nio中ByteBuffer
1. 读写公用一个pos索引
2. 不支持动态扩展
****** 读写索引
1. 读 readIndex
2. 写 writeIndex
****** CompositeByteBuf
提供了零拷贝的组合ByteBuf的方法
****** 
**** Selector
Selector(选择器)是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接

***** 概念
+ registrations
+ register 使用selector为channel注册
+ cancel 方法在cancelled-key上同步
+ selection 
***** 三个key set
1. key set
2. select-key set
   1. cancelled-key
**** Channel
***** FileChannel
****** 使用方式
#+BEGIN_SRC java
  FileChannel fileChannel = new RandomAccessFile(new File("db.data"), "rw").getChannel();
#+END_SRC
***** ServerSocketChannel
一个SelectableChannel,面向流的socket监听的channel
***** SelctableChannel
可以通过Selector实现多路复用的channel
1. 为了实现多路复用,此类的实例必先实现register方法
****** BlockingMode
1. blocking mode下 当前线程要等待当前channel上的io完成(成功或者失败).
2. non-blocking mode 当channel上的io不能立即完成时,将控制权返回给当前线程,可能会在将来的某个时刻再次考察io的结果,这可能造成某一刻会读出来比你预想的要小的数据
3. 使用selector 的多路复用需要配合non-blocking mode使用
*** 3. MMAP
FileChinnel 已经很快了，mmap是怎么更快的

**** 原理
将文件映射到虚拟内存上，在需要的时候根据缺页加载的机制加载
*** 为什么系统不能直接访问java堆上的内容呢?
[[https://www.bilibili.com/video/av33707223?p=38][参考]]
1. jvm上的对象在GC时可能会发生移动，操作系统访问内存的方式是固定的地址。这样在GC的时候，虽然jvm内对移动对象的访问有jvm控制以保证合法，但是JNI的方法不会因为GC而停下，这时内存出现错乱。
2. 操作系统来控制硬件和内存之间的交互，如1所说，现在操作系统直接操作jvm的堆上对象可能会发生错误。那怎么解决呢？
3. 要么让对象不动，那就得禁止GC。java没了GC！！！没得玩了
4. 要么不让系统直接操作堆上内存。由jvm先安全的copy出一份到堆外内存来，然后系统来调度读写。这个过程中由jvm保证这块堆外内存的正确性。这基于内存拷贝非常快。一方面，jvm的检查一致性压力没那么大，一方面相比于与硬件的交互，这个copy动作非常快，所以性能也还可以
* lang3
** toString
[[https://blog.csdn.net/z69183787/article/details/76146728][参考]]
* inbox
+ 静态方法只能继承，不能重写。
+ final修饰引用类型变量，则这个变量不能修改指针，但是指向的对象内部是可以改变的,修饰的数组长度可变么
+ 静态代码块只能执行一次
+ java.lang.包不需要导入
+ 常量池，看一下老年代被取消后它跑哪去了
+ instance方法判断是不是某类对象或者是不是实现了某个接口
** cow 
copy on write
1. 写时复制，无锁读
2. 适用场景，读多写少，且集合整体较小
3. 优点：读时无锁，性能高
4. 缺点: 写入性能差，iterater中看到的数据无法保证实时性，内存消耗翻倍
** NavigatableMap
1. 可以取近似key的值，导航至最接近给定目标的能力
** 
