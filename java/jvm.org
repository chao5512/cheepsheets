#+title: jvm
* hotspot由来
JIT编译器在运行时创建方法使用文件，然后一步一步的优化每一个方法，有时候会主动的优化应用的行为。这些优化技术，比如积极的分支预测（optimistic branch prediction），如果不先分析应用就不能有效的使用。这样将频繁调用的部分提取出来，编译成本地代码，也就是在应用中构建某种热点（即HotSpot，这也是HotSpot JVM名字的由来）。使用
* jvm类型
以下两种是不同的虚拟机
** client
** server
具备更高级的优化算法的虚拟机
* jvm工作模式
** -Xint
强制JVM以解释方式执行所有的字节码
** -Xcomp
JVM在第一次使用时会把所有的字节码编译成本地代码
** -Xmixed
对于字节码中多次被调用的部分，JVM会将其编译成本地代码以提高执行效率；而被调用很少（甚至只有一次）的方法在解释模式下会继续执行，从而减少编译和优化成本
** 代码中获取jvm工作模式
#+begin_src java
  System.out.println(System.getProperty("java.vm.name")); //获取JVM名字和类型
  System.out.println(System.getProperty("java.vm.info")); //获取JVM的工作模式
#+end_src

* 垃圾回收
** 简介
+ 垃圾收集器跟踪所有正在使用的对象,并把其余部分当做垃圾
+ 第一款垃圾收集器是1959年为Lisp语言开发的, 此后 Lisp 的垃圾收集技术也一直处于业界领先水平。
** 基本概念
*** mutator
用来指应用程序
*** collector
用来指回收器
*** 垃圾回收的评价标准
**** 吞吐量
单位时间里的处理能力
**** latency
暂停mutator的时间
**** 堆使用效率
例如，标记一整理算法总会在堆中保留一个连续的空白区域。它相较于标记清楚算法而言，在堆的使用率上面就会显得比较低
**** 访问的局部性
相关联的对象一般会更可能被连续访问，这就是访问的局部性。所以如果一个GC算法能够将相关的对象重排在一起，那对于mutator的来说，访问起来就非常丝滑了
** STW 存在的必要性
垃圾收集过程中, 需要暂停应用程序的所有线程。假如不暂停,则对象间的引用关系会一直不停地发生变化, 那样就没法进行统计了， 如何在对象间引用关系变化的时候进行标记？
** 回收位置
+ heap : 回收性价比高
+ 方法区 : 虚拟机规范没有要求，商用虚拟机都实现了(回收废弃 *常量* 和 *无用的类*)
  + 类回收的条件（非常苛刻、证类无用）
    1. 任何该类的实例都已经被回收
    2. 加载该类的classloader已经被GC
    3. 该类对应java.lang.class对象没有在任何地方被引用，且不存在任何可以通过反射访问该类的方法
  + 需要关注方法区垃圾回收（类卸载）的场景
    + 大量使用反射、动态代理、CGlib等字节码生成工具
    + OSGI类的频繁自定义classloader的场景
    + 动态生成jsp
** 回收算法（分段式如何保证回收事务？）
*** 标记清除(保守式GC，不移动对象)
  + 标记会stw
  + 清除(不整理)效果不好，内存碎片问题
  + 遍历整个堆，所以消耗时间与堆大小成正比
**** 空闲链表
在清除阶段，把不可达的对象作为分块链接到空闲链表。这里涉及到该对象的头(地址和size)，域(next指向空闲链表中的下一个回收对象)
***** mutator在空闲链表中选择空间来分配新对象时
可以指定一些策略，如
1. first-fit：找到第一个满足大小的块就返回
2. best-fit：找到满足大小且最小的块返回
3. worst-fit: 找到满足大小且最大的块返回
**** 优化
***** 清除阶段尽可能的合并小分块
具体的，如果发现此次清除的分块与上一个清除的分块是连续的，那么把他们合并成一个大块
***** 多个空闲链表
把大分块和小分块分到不同的空闲链表管理，这样在分配的时候，可以根据size加速分配过程
**** 缺点
***** 与写时复制(copy-on-write)不兼容
写时复制：在linux中复制(fork)进程，并不会直接复制该进程的内存空间，而是共享内存空间，只有当进程对内存有写操作时才会真正的复制内存空间，而标记-清除算法，即使mutator没有重写对象，GC也会重写标志位，造成不必要的复制

*** 标记整理
  + 整理过程会移动对象，这样，就需要更新指向这个对象的引用，这是一个stw过程，停顿但是安全，这就是为什么CMS尽量不整理
+ 复制算法(空间换时间)
  + 现在的商用jvm都才用 **复制算法*实现新生代*
  + hostSpot ： eden区 : survivor区 = 8 : 1 : 1 (survivor个数可以设置)
  + 优点是标记和复制可以同时做
  + 效率不一定高：正向作用是只需要扫描存活的对象，逆向作用是额外多一次复制操作，在存活率高的情况下放大逆向作用
  + *由于上述原因，复制算法适用于系统中会有大量生命周期特短的对象*
+ 分代算法
  + 分代也存在问题，即回收一个分代时，另一个分代中的所有对象都称为GC root，使用 *card-marking* 解决这个问题，[[http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html][参考]]
  + 适合的场景 : 系统中大部分对象要么活得长，要么死的快

*** 复制算法
1. 空间利用率不高
** 垃圾回收算法
*** 问题
1. 高速缓存如何影响collector性能？ 答：一旦算法没有利用上locality，那么它将失去高速缓存带来的预取或者批量的特性
2. 堆的可遍历性，有无填充字节要怎么遍历？
** 死亡鉴定
没有引用即为死
*** 四种引用类型
+ hbase用了 *软引用* 和 *弱引用* 的pool
+ 强引用：声明赋值的引用，只要有强引用指着，内存不够也不回收，oom
+ 软引用：留校察看的引用，引用的对象只有在内存不够的时候才回收
+ 弱引用：只要发生GC，弱引用关联的对象都会被回收
+ 虚引用(Phantom)
+ 引用队列 : 可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。
  
** 判活的方法
*** 引用计数
+ 缺点 ： 需要额外判断循环引用
+ Objective-C 使用引用计数
*** 可达性分析
+ java 、 c#
**** java中的GC root？
gcroot分两类
1. 生命周期很长的对象，比如类的静态变量(方法区中的静态引用、常量)
2. 一定有用的对象，比如栈帧(包括本地方法栈)的局部变量
** 垃圾回收的定义
*** minor GC
+ 用于回收eden区
+ 触发时机 : 新对象生成后判断一下更新的eden区的使用情况，放不下的时候呢？
*** full GC
+ 对整个JVM进行整理(young、old、perm)
+ 触发时机
  + Old满了
  + perm满了
  + system.gc()建议gc
** 垃圾回收器
*** 总览
#+DOWNLOADED: file:/Users/wangchao/Desktop/截屏2019-11-22上午1.13.48.png @ 2019-11-22 01:16:22
[[file:%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2019-11-22_01-16-22_%E6%88%AA%E5%B1%8F2019-11-22%E4%B8%8A%E5%8D%881.13.48.png]]
*** Serial
**** 图
#+DOWNLOADED: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3544756367,1523761064&fm=26&gp=0.jpg @ 2019-11-22 01:35:16
[[file:%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2019-11-22_01-35-15_u=3544756367,1523761064&fm=26&gp=0.jpg]]
**** 文
+ client端的默认收集器
+ 最早的收集器,单线程进行GC
+ New和Old generation都可以使用
+ 在新生代,采用复制算法;在老年代( *存活对象多，复制开销因而大*)采用Mark-Compact算法
+ 因为是单线程GC,没有多线程切换的额外开销,简单实用
*** ParNew
+ Serial收集器在新生代的多线程版本
+ 使用复制算法(因为针对新生代)
+ 只有在多CPU的环境下,效率才会比 Seria收集器高
+ 可以通过 -XX: ParallelGCThreads来控制GC线程数的多少。需要结合具体CPU的个数
+ Server模式下 *新生代* 的缺省收集器
*** Parallel Scavenge
Para|lel Scavenge收集器也是一个多线程收集器,也是使用复制算法,但它的对象分配规则与回收策略都与 ParNew收集器有所不同,它是以 *吞吐量最大化(即GC时间占总运行时间最小)* 为目标的收集器实现, *允许用较长时间的STW换取总吞吐量最大化* 
*** SerialOld
SerialOld是单线程收集器,使用 *标记一整理算法*,是 *老年代的收集器*
*** ParallelOld
老年代版本吞吐量优先收集器,使用 *多线程* 和 *标记一整理算法*,JWM1.6提供,在此之前,如果新生代使用了PS收集器的话,老年代除 Serial old外别无选择,因为PS无法与CMS收集器配合工作
+ Parallel Scavenge+ Parallel old=高吞吐量,但GC停顿可能不理想
*** 标记算法，黑色和灰色对象都是确定存活的对象。灰色对象的集合构成了当前collector正在扫描的分界面（wavefront）。从分界面的角度看，灰色是正在分界面上，白色是在分界面之前，黑色是在分界面之后。
2. collector不会再次扫描黑对象的字段
**** 那么，什么情况下会漏掉存活的对象
两件事同时发生
1. mutator把白对象a赋值给了黑对象的某个字段
2. 白对象失去了所有能从会对象指向它的引用
黑对象持有了指向白对象的引用。根据定义，collector已经不会再去遍历黑对象的字段，所以发现不了这里还有一个活引用指向这个白对象。如果还有某个灰对象持有直接或间接引用能到达这个白对象，那就没关系；如果从灰对象出发的所有引用到这个白对象的路径都不幸被切断了，那这个白对象就要被漏扫描了。
**** 两种不同的方式
***** SATB
把marking开始时的逻辑快照里所有的活对象都看作时活的。具体做法是在write barrier里把所有旧的引用所指向的对象都变成非白的（已经黑灰就不用管，还是白的就变成灰的）
***** Incremental update
只要在write barrier里发现要有一个白对象的引用被赋值到一个黑对象的字段里，那就把这个白对象变成灰色的（例如说标记并压到marking stack上，或者是记录在类似mod-union table里）
* GC参数
** 调试常用参数
#+begin_example
  -verbose:gc
  -Xms20M
  -Xmx20M
  -Xmn10M
  -XX:+PrintGCDetails
  -XX:SurvivorRatio=8
  -XX:PretenureSizeThreshold=4194304
  -XX:+UseSerialGC
#+end_example
+ -XX:MaxTenuringThreshold=5  : 晋升年龄的最大值，也就是有可能在小于5的时候就晋升，该参数的默认值为15,CMS中默认值为6,G1中默认为15(在JVM中,该数值是由4个bit来表示的,所以最大值1111,即15). 经历了多次Gc后,存活的对象会在 From Survivor与 To Survivor之间来回存放,而这里面的一个前提则是这两个空间有足够的大小来存放这些数据,一种策略是计算每个年龄对象的大小,如果达到某个年龄后发现总大小已经大于了 Survivor空间的50%,那么这时就需要调整阈值,不能再继续等到默认的15次gc,因为这样会导致 Survivor空间不足,所以需要调整阈值,让这些存活对象尽快完成晋升。
** 定位问题
*** gclog和dump配置
1. -XX:+PrintGCDateStamps
2. -XX:+PrintGCDetails
3. -XX:+PrintGCTimeStamps

4. -Xloggc:../logs/gc_region-%t.log
5. -XX:+HeapDumpOnOutOfMemoryError
6. -XX:HeapDumpPath=/tmp/logs/dump-%t
** GC-log
含义解析样例
+ 正常gc
#+begin_example

  [ GC (Allocation Failure)[PSYoungGen: 5646K->624K(9216K)] 5646K->4728K(19456K),0.0044403 secs] [Times: user=0.03 sys=0.00, real=0.01 secs
  [ GC                   是什么GC? 是minorGC，如果是FullGC会显示FullGC
  (Allocation Failure)  GC的原因是？Allocation failure 分配内存后达到新生代设置的GC阈值，这里意为尚可分配，但是有点挤了。若压根分配不开，会直接在老年代分配
  [PSYoungGen:	本次会收使用什么垃圾收集器？ 分代parallel scavenge      
  5646K->624K(9216K)] 			     具体的，回收前新生代被使用了5646k，回收后新生代被使用624k，总的新生代可用空间9216k(配置定死的)
  5646K->4728K(19456K),		     回收前总的被使用的堆5646k，回收后总的堆被使用4728k，总堆可用大小为19456（配好的）
  0.0044403 secs] [Times: user=0.03 sys=0.00, real=0.01 secs	总共用了0.0044403秒，其中用户空间糊了0.03秒，内核空间几乎是0.00，真正运行了0.01秒
#+end_example

+ full GC
#+begin_example
  [Full GC (Ergonomics) [PSYoungGen: 608K->0K(9216K)] [ParOldGen: 5128K->5616K(10240K)] 5736K->5616K(19456K), [Metaspace: 3290K->3290K(1056768K)], 0.0057821 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
  [Full GC
  (Ergonomics)		GC本身需要的一次GC
  [PSYoungGen: 608K->0K(9216K)]	新生代回收到0了
  [ParOldGen: 5128K->5616K(10240K)] 5736K->5616K(19456K),// 回收前5128k，回收后5616k，老年代总共10240k，后面的一对数为对空间回收前后的值，堆总大小为19456k
  [Metaspace: 3290K->3290K(1056768K)], //元空间在GC前后的变化
  0.0057821 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
#+end_example

+ Full GC - another version
#+begin_example
2020-05-25T22:32:30.549+0800: 30.993: [Full GC (GCLocker Initiated GC) 2020-05-25T22:32:30.549+0800: 30.993: 
[CMS: 3086306K->3086306K(3086784K), 0.6462093 secs] 4082949K->3768837K(4083584K), // 回收前后
[Metaspace: 37917K->37917K(1083392K)], 0.6462875 secs] [Times: user=0.65 sys=0.00, real=0.64 secs]

#+end_example
** 查看虚拟机默认参数
#+BEGIN_SRC sh
  java -XX:+PrintCommandLineFlags -version
#+END_SRC

+ -XX:+UseCompressedOops : 指针膨胀时压缩
+ -XX:+UseParallelGC：新生代用Parallel scavenge 老年代用 parallel old
** -XX:UseSerialGC 
+ -XX:PretenureSizeThreshold=<字节为单位的一个数> : 老年代预备役的大小，超过这个值将直接分配在老年代

** XX:+UseStringDeduplication
+ 限制
  1. 只适用于G1
  2. 只适用于长期存活的对象，-XX:StringDeduplicationAgeThreshold=6，默认是3, 表示一个string对象经过几次GC为长期存活
  3. 可能会增加GC时间，因为有附加的清除重复字符串的工作，但影响可能是减少随后的GC频率和随后的GC过程中扫描的负担
+ -XX:+PrintStringDeduplicationStatistics查看去重信息

** ExitOnOutOfMemory and CrashOnOutOfMemory的区别
1. ExitOnOutOfMemory 相比处理oom，更倾向于重新启动一个进程实例
2. CrashOnOutOfMemory 在oom的时候生成报告文件

** ExplicitGCInvokesConcurrent
[[https://blog.csdn.net/ning0323/article/details/76505378][参考]]
G1 GC的System.gc()默认还是full GC，也就是serial old GC。只有加上 -XX:+ExplicitGCInvokesConcurrent 时G1才会用自身的并发GC来执行System.gc()——此时System.gc()的作用是强行启动一次global concurrent marking；一般情况下暂停中只会做initial marking然后就返回了，接下来的concurrent marking还是照常并发执行。

** UseCompressedClassPointers
压缩指针

** UseGCOverheadLimit
1. 1.6引入，当并行收集器花费了98%的时间却只回收了2%的内存时，会抛出java.lang.OutOfMemoryError：GC overhead limit exceeded这个异常
2. 如果需要的话，可以使用-XX:UseGCOverheadLimit来disable掉这个特性

** G1

*** G1MixedGCLiveThresholdPercent=65
如果一个region中存活的部分占整个region的65%，则这个region不会参与到mixed gc收集中
* OOM
[[https://www.cnblogs.com/intsmaze/p/9550256.html][为什么使用dump而不是报错日志]]

todo 
1. 排查内存溢出
** 生成dump文件的集中方式
1. jmapdump
2. jconsole HotSpotDiagnosticMXBean
3. jvm参数
   1) -XX:+HeapDumpOnOutOfMemoryError
   2) -XX:HeapDumpPath=/home/wangchao/brfs/ 这里配置为绝对路径，在路径下生成形如java_pid176692.hprof的dump文件，不要写死文件名
4. hprof 命令，查看cpu和内存
   1. [[http://docs.oracle.com/javase/8/docs/technotes/samples/hprof.html][参考]]
* 线程状态
[[https://www.uml-diagrams.org/java-thread-uml-state-machine-diagram-example.html][参考]]

#+DOWNLOADED: https://www.uml-diagrams.org/examples/state-machine-example-java-6-thread-states.png @ 2019-12-08 18:28:57
[[file:%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/2019-12-08_18-28-55_state-machine-example-java-6-thread-states.png]]

** waiting状态的线程被唤醒的时候进入blocked状态
#+DOWNLOADED: https://www.uml-diagrams.org/examples/state-machine-example-java-6-thread-states.png @ 2019-11-20 11:13:33
[[file:%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/2019-11-20_11-13-33_state-machine-example-java-6-thread-states.png]]
* 类加载
** lazy loading
- 在类被首次主动使用时才会类的初始化
- 但并没有延迟加载，即类的加载在首次主动使用前就完成了，不过如果加载失败，这个错误信息要等到首次主动使用才会抛出(延迟抛出)
- 当一个类初始化的时候，它所实现的接口是不会被初始化的
- classloader去load一个类的时候不会导致类的初始化，只有用反射class.forname的时候才会初始化


** 类加载过程
1. loading
2. linking
   1. verification
   2. preparation ： 为静态成员变量赋默认值
   3. resolution ： 将类、方法、属性等符号引用（常量池中存储的是是符号如：Lang.java.String）转换为直接引用(String类在内存中的地址)
3. initializing ： 调用初始化方法，为静态成员变量赋初始值
** 自定义类加载器
*** 场景
1. 冲突隔离
2. 热加载
3. 代码保护
** 双亲委托机制
*** 为啥？
*安全机制，为了防止恶意代码* ，比如Object类只能有Bootstrap Classloader加载，即使其它加载器想要加载Ojbect或者修改的Object类，都最终会委托给启动加载器，然后就会被发现是恶意的
*** 上下文加载器
为了破坏双亲委托机制
使得父类可以使用子类的加载器
**** 使用模式
- 获取
- 替换
- 还原
* 字节码 - class
* volitile怎么保证有序性

* 内存结构
Hotspot中方法栈和JNI方法栈是同一个
1. 堆: 线程共享,存放所有实例对象
2. 方法区: 线程共享,存储类相关信息,常量,静态变量,即时编译后的代码
3. 栈: 线程私有,局部变量表,操作栈,动态链接,方法出口,对象指针
4. 程序计数器
* 内存模型
线程本地内存和主内存的抽象关系
* 主要组件和架构
- 执行引擎
  - GC
  - JIT
* 工具
** jvisualvm
- poid 优先级
- 线程dump
- 堆dump
- Metaspace监控
** jconsole
- 线程监控可以看到线程的总等待、总阻止线程数
- 检查死锁的线程
- HotSpotDiagnosticMXBean ： 生成内存快照
** jmap
- clstat : 查看类加载器的统计数据
- heapheap :堆和gc的统计数据
- jmap -dump:file=3.dump 19076 : 生成内存快照
- -histo : 内存直方图
** jstat
- gc gc统计信息
  - MC : current metaspace capacity  （KB）
  - MU : metaspace Utillization 已用空间
- jstat -gc -t <pid> 1s : 这个命令有歧义
- 可以用来观察内存使用变化情况
*** in action 
**** jstat -gc pid 500 100
可以看出新生代增长很快,老年代也涨的很快
#+begin_example
  S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
   0.0    0.0    0.0    0.0   3964928.0 458752.0 2326528.0   490449.6  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 524288.0 2326528.0   524536.3  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 589824.0 2326528.0   541579.6  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 688128.0 2326528.0   575666.3  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 753664.0 2326528.0   609753.0  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 819200.0 2326528.0   626796.4  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 884736.0 2326528.0   660883.1  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 983040.0 2326528.0   694969.8  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1081344.0 2326528.0   729056.5  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1114112.0 2326528.0   746099.8  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1212416.0 2326528.0   780186.5  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1310720.0 2326528.0   814273.2  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1441792.0 2326528.0   848360.0  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1507328.0 2326528.0   865403.3  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1638400.0 2326528.0   899490.0  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1736704.0 2326528.0   916533.4  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1802240.0 2326528.0   950620.1  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1900544.0 2326528.0   984706.8  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1998848.0 2326528.0  1018793.5  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2064384.0 2326528.0  1052880.2  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2162688.0 2326528.0  1086966.9  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2228224.0 2326528.0  1104010.2  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2293760.0 2326528.0  1138096.9  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2392064.0 2326528.0  1172183.6  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2490368.0 2326528.0  1206270.3  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2523136.0 2326528.0  1223313.7  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2621440.0 2326528.0  1257400.4  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0   32768.0  0.0   32768.0 3932160.0 32768.0  2326528.0   356682.9  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 163840.0 2326528.0   358001.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 262144.0 2326528.0   375045.0  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 327680.0 2326528.0   409131.7  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 425984.0 2326528.0   443218.4  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 491520.0 2326528.0   477305.1  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 589824.0 2326528.0   511391.8  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 655360.0 2326528.0   528435.1  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 720896.0 2326528.0   562521.9  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 819200.0 2326528.0   596608.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 917504.0 2326528.0   630695.3  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 983040.0 2326528.0   664782.0  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1081344.0 2326528.0   698868.7  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1114112.0 2326528.0   715912.0  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1212416.0 2326528.0   749998.7  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1310720.0 2326528.0   784085.4  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1409024.0 2326528.0   818172.1  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1474560.0 2326528.0   852258.8  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1572864.0 2326528.0   886345.5  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1638400.0 2326528.0   903388.9  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1736704.0 2326528.0   937475.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1802240.0 2326528.0   971562.3  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1900544.0 2326528.0  1005649.0  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1966080.0 2326528.0  1039735.7  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2064384.0 2326528.0  1073822.4  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2129920.0 2326528.0  1090865.8  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2228224.0 2326528.0  1124952.5  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2293760.0 2326528.0  1159039.2  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2392064.0 2326528.0  1193125.9  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2490368.0 2326528.0  1227212.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2555904.0 2326528.0  1261299.3  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2621440.0 2326528.0  1278342.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2719744.0 2326528.0  1312429.3  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2818048.0 2326528.0  1346516.0  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2883584.0 2326528.0  1380602.7  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2949120.0 2326528.0  1397646.1  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3047424.0 2326528.0  1431732.8  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3080192.0 2326528.0  1448776.1  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3178496.0 2326528.0  1482862.8  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3244032.0 2326528.0  1516949.5  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3309568.0 2326528.0  1533992.9  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3407872.0 2326528.0  1568079.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0    0.0    0.0    0.0   3964928.0 98304.0  2326528.0   371256.6  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 196608.0 2326528.0   405343.3  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 294912.0 2326528.0   422386.7  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 425984.0 2326528.0   456473.4  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 524288.0 2326528.0   490560.1  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 622592.0 2326528.0   507603.4  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 753664.0 2326528.0   541690.1  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 819200.0 2326528.0   575776.8  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 917504.0 2326528.0   609863.5  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 983040.0 2326528.0   643950.2  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1048576.0 2326528.0   660993.6  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1146880.0 2326528.0   695080.3  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1212416.0 2326528.0   729167.0  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1310720.0 2326528.0   763253.7  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1409024.0 2326528.0   797340.4  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1441792.0 2326528.0   814383.8  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1540096.0 2326528.0   848470.5  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1638400.0 2326528.0   882557.2  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1736704.0 2326528.0   916643.9  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1802240.0 2326528.0   950730.6  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1900544.0 2326528.0   984817.3  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1966080.0 2326528.0  1001860.6  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2031616.0 2326528.0  1035947.3  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2129920.0 2326528.0  1070034.0  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2228224.0 2326528.0  1104120.7  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2293760.0 2326528.0  1138207.4  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2359296.0 2326528.0  1155250.8  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2457600.0 2326528.0  1189337.5  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
#+end_example


** jcmd (1.7新增的)
- jcmd <pid> help ： 看一下可以对这个进程做什么
- jcmd <pid> help <具体命令> : 具体命令的帮助
- jcmd <pid> VM.flags : 查看jvm启动参数
- jcmd <pid> PerfCounter.print : 统计jvm性能
- jcmd <pid> VM.uptime : 这个jvm启动多长时间了
- jcmd <pid> GC.class_histogram : 类的统计信息  可以用head查看前几行
- jcmd <pid> Thread.print : 线程堆栈信息，grep deadlock 看有没有死锁及死锁的详细信息
- jcmd <pid> GC.heap_dump <目标文件> : 导出dump文件，然后用jvisualvm装载(打开gui>菜单栏>装入文件)文件分析，heap dump会导致程序暂停一下
- jcmd <pid> VM.system_properties : 查看jvm的信息，也就是 ps -ef 输出的那一大坨信息
- 获得命令行参数
- 获得jvm版本信息
** jstack
与jcmd pid Thread.print差不多，但jstack是专门获得线程堆栈信息的
- jstack <pid>
** jmc(java mission control)
- 与jcmd差不多，但是是实时的
- 可以jcmd生成JFR(java fligh recorder:飞行记录器)文件
** jhat
**** 可以转储dump文件
**** 可以分析dump文件(没有图形界面的时候用)
1. 可以按条件查询，比如查询某个class的所有实例

** heapHore
** gceasy
** top
查看cpu到底在干什么
1. 使用top命令查找CPU使用率最高的进程

2. top -H -p pid 找到CPU使用率最高的线程(-H 线程模式)

3. printf “%x\n” tid 把线程ID输出为16进制(java 中线程nid(16进制)-->linux 中tid(10进制))

4. jstack pid | less 从中模式匹配nid，查看对应代码
** gc日志分析
GCViewer
*** 使用步骤
1. git clone git@github.com:chewiebug/GCViewer.git
2. mvn clean package
3. java -jar gcviewer-xxx.jar
4. 装入log
** mat
*** 分析命令
- org.eclipse.mat.api:suspects 找到可以的内存泄漏
#+BEGIN_SRC sh
  ./ParseHeapDump.sh ~/brfs/dumpdir/dump-data org.eclipse.mat.api:suspects org.eclipse.mat.api:overview org.eclipse.mat.api:top_components
#+END_SRC
* 字符串常量池
* to read
[[https://cloud.tencent.com/developer/article/1451049][干货]]
[[https://www.ps.uni-saarland.de/courses/gc-ws01/slides/generational_gc.pdf][分代回收]]
[[http://users.cecs.anu.edu.au/~steveb/pubs/papers/wb-ismm-2004.pdf][barries]]
* NMT（native memory trace)
直接内存排查,是在jvm代码中添加追踪点的方式实现，因此第三方native库的内存分配追踪不到
** 开启nmt
会有5%-10%的性能损耗

   #+begin_src text
     -XX:NativeMemoryTracking=[off | summary | detail]
   #+end_src
** 访问nmt
使用jcmd访问nmt
#+begin_src shell

  jcmd <pid> VM.native_memory [summary | detail | baseline | summary.diff | detail.diff | shutdown] [scale= KB | MB | GB]

  # baseline 创建一个内存快照 以用于后面的比较
  # summary.diff 比较和上次快照的差异  打印总结
  # detail.diff 比较和上次快照的差异 打印详细信息
#+end_src
** nmt 报告详解
| Category                 | Description                                                  |
|--------------------------+--------------------------------------------------------------|
| Java Heap                | 对象分配的地方                                               |
| Class                    | 类的元信息                                                   |
| Code                     | 生成的代码                                                   |
| GC                       | GC用的数据，例如card table                                          |
| Compiler                 | 编译器生成代码的时候需要的内存                               |
| Symbol                   | Symbols                                                      |
| Memory Tracking          | NMT需要的内存                                                |
| Pooled Free Chunks       | chunks in the arena chunk pool                               |
| Shared space for classes | Memory mapped to class data sharing                          |
| Thread                   | 线程使用的内存，包括数据结构、资源、handle area              |
| Thread stack             | Thread stack                                                 |
| Internal                 | 不在上面的分类中，类似command line parser, JVMTI, properties |
| UnKnown                  | 不知道的区域                                                 |
|                          |                                                              |

arena 动态分配内存的memory pool
* 堆外内存占用高排查
** 情景
线上报警内存吃紧
*** jvm参数设置
    #+begin_src text
      -XX:+ExitOnOutOfMemoryError
      -XX:+ExplicitGCInvokesConcurrent
      -XX:G1HeapRegionSize=33554432
      -XX:G1MixedGCLiveThresholdPercent=50
      -XX:+HeapDumpOnOutOfMemoryError
      -XX:HeapDumpPath=logs
      -XX:InitialHeapSize=5368709120
      -XX:InitiatingHeapOccupancyPercent=5
      -XX:MaxHeapSize=5368709120
      -XX:+PrintGC
      -XX:+PrintGCDateStamps
      -XX:+PrintGCDetails
      -XX:+PrintGCTimeStamps
      -XX:+UnlockExperimentalVMOptions
      -XX:+UseCompressedClassPointers
      -XX:+UseCompressedOops
      -XX:+UseG1GC
      -XX:+UseGCOverheadLimit
    #+end_src
这里设置的堆内存是5G，业务逻辑没有使用直接内存
*** 实际内存占用
    #+begin_src bash
      pmap -x 13 |sort -n -k3 |tail -2

      内存地址起始     申请的虚拟内存 实际占用  脏页
      0000000680000000 5251072 4413520 4413456 rw---   [ anon ]
      total kB         12833836 8825944 8814008
    #+end_src
堆内占用约等于4G，堆外占用约等于4G
** 排查过程
*** 怀疑堆内存在指向堆外内存的短生对象晋升到老年代偷生
1. 排查gc日志，我们用的G1，发现确实没有触发过mixed GC，确实存在这种可能性
2. 手动触发full gc （jmap -histo:live pid）,发现内存占用并没有降下来
3. 总结：如果如1所述，那么full gc后堆外被指向的内存是有机会被回收的，但是在我们full gc 完长时间观察，发现内存进程占用并未降下来
*** 使用linux core dump工具查看堆外内存大概是什么内容
**** pmap
1. 用来查看一个进程的内存占用
2. -x 显示更详细的信息
使用pmap -x ${pid}查看进程内存占用,发现大量的几十兆的内存块
**** grep ${可疑内存的起始地址} /proc/${pid}/maps 
内存地址形式[7fec2650e000-7fec26510000],ps：这里面的地址没有pmap前面的三个0
**** gdb
     #+begin_src bash
       gdb --batch --pid ${pid} -ex "dump memory out.dump 0x7fec2650e000 0x7fec26510000"


     #+end_src
得到out.dump
**** 查看可读字符，希望有什么线索
     #+begin_src bash
       # 打印out.dump 文件中长度超过10的可读字符
       strings -10 out.dump
     #+end_src
发现其中有大量关于rocksdb的内容，包括我们写到rocskdb的kv和rocksdb自身的结构(过滤器，索引等)
至此发现堆外内存占用高应该是与rocksdb有关
** rocskdb配置
1. max_background_flushes ： memtable flush的并发数
2. max_background_compactions ： memtable compaction 或者sst compaction的并发数
3. block_cache: 读缓存容量
4. allow_os_buffer： sst文件是否使用系统缓存
5. write_buffer_size： 单个write-buffer容量，差不多快满了要触发 flush
6. max_write_buffer_number： 单个列族中的memtable上限
7. min_write_buffer_number_to_merge： 配置为多个用来触发in-memory compaction
8. level0_file_num_compaction_trigger : L0的sst文件上限，超了会触发compaction
*** 多列族堆外内存泄露
按如上配置，我们对rocksdb只进行单列族的内存限制，但是并未对列族数限制，内存随着列族的增加而增加，没法控制

*** 写限速
**** 原因
1. 太多的memtable
2. 太多L0 sst
3. 太多的等待compaction的bytes
*** 配置调整
我们的问题是堆外占用过高，rocksdb占用4G左右
1. 调小write-buffer 从256M调至64M
2. 业务写多读少，减少读缓存，1G调至256M
3. 单个列族的write-buffer数量为5，最多4个memtable配合一个immutable memtable
4. 关闭in-memory compaction 读少所以不优化读放大
5. L0 sst=8 调高或不调，调小会触发写限速
6. 代码中增加write-buffer manager 限制总内存
*** 内存估算
rocksdb 占用内存 = block cache + write-buffer总内存
按如上配置，rocskdb占用1.7G左右，平稳支撑40w/min的写入
* 堆外内存溢出
堆外内存溢出的排查从找到引起内存问题的native user开始.可以从报错日志或者通过对潜在所有的native user进行trial来进行.
