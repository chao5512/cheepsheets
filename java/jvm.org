#+title: jvm
* 垃圾回收
** 简介
+ 垃圾收集器跟踪所有正在使用的对象,并把其余部分当做垃圾
+ 第一款垃圾收集器是1959年为Lisp语言开发的, 此后 Lisp 的垃圾收集技术也一直处于业界领先水平。

** STW 存在的必要性
垃圾收集过程中, 需要暂停应用程序的所有线程。假如不暂停,则对象间的引用关系会一直不停地发生变化, 那样就没法进行统计了
** 回收位置
+ heap : 回收性价比高
+ 方法区 : 虚拟机规范没有要求，商用虚拟机都实现了(回收废弃 *常量* 和 *无用的类*)
  + 类回收的条件（非常苛刻、证类无用）
    1. 任何该类的实例都已经被回收
    2. 加载该类的classloader已经被GC
    3. 该类对应java.lang.class对象没有在任何地方被引用，且不存在任何可以通过反射访问该类的方法
  + 需要关注方法区垃圾回收（类卸载）的场景
    + 大量使用反射、动态代理、CGlib等字节码生成工具
    + OSGI类的频繁自定义classloader的场景
    + 动态生成jsp
** 回收算法（分段式如何保证回收事务？）
+ 标记清除
  + 标记会stw
  + 清除(不整理)效果不好，内存碎片问题
+ 标记整理
  + 整理过程会移动对象，这样，就需要更新指向这个对象的引用，这是一个stw过程，停顿但是安全，这就是为什么CMS尽量不整理
+ 复制算法(空间换时间)
  + 现在的商用jvm都才用 **复制算法*实现新生代*
  + hostSpot ： eden区 : survivor区 = 8 : 1 : 1 (survivor个数可以设置)
  + 优点是标记和复制可以同时做
  + 效率不一定高：正向作用是只需要扫描存活的对象，逆向作用是额外多一次复制操作，在存活率高的情况下放大逆向作用
  + *由于上述原因，复制算法适用于系统中会有大量生命周期特短的对象*
+ 分代算法
  + 分代也存在问题，即回收一个分代时，另一个分代中的所有对象都称为GC root，使用 *card-marking* 解决这个问题，[[http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html][参考]]
  + 适合的场景 : 系统中大部分对象要么活得长，要么死的快

** 死亡鉴定
没有引用即为死
*** 四种引用类型
+ hbase用了 *软引用* 和 *弱引用* 的pool
+ 强引用：声明赋值的引用，只要有强引用指着，内存不够也不回收，oom
+ 软引用：留校察看的引用，引用的对象只有在内存不够的时候才回收
+ 弱引用：只要发生GC，弱引用关联的对象都会被回收
+ 虚引用(Phantom)
+ 引用队列 : 可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。
  
** 判活的方法
*** 引用计数
+ 缺点 ： 需要额外判断循环引用
+ Objective-C 使用引用计数
*** 可达性分析
+ java 、 c#
+ 什么可以算是root？
  + 栈中引用(存在即有用的)
  + 活动线程
  + 方法区中的静态引用
  + JNI中的引用
** 垃圾回收的定义
*** minor GC
+ 用于回收eden区
+ 触发时机 : 新对象生成后判断一下更新的eden区的使用情况，放不下的时候呢？
*** full GC
+ 对整个JVM进行整理(young、old、perm)
+ 触发时机
  + Old满了
  + perm满了
  + system.gc()建议gc
** 垃圾回收器
*** 总览
#+DOWNLOADED: file:/Users/wangchao/Desktop/截屏2019-11-22上午1.13.48.png @ 2019-11-22 01:16:22
[[file:%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2019-11-22_01-16-22_%E6%88%AA%E5%B1%8F2019-11-22%E4%B8%8A%E5%8D%881.13.48.png]]
*** Serial
**** 图
#+DOWNLOADED: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3544756367,1523761064&fm=26&gp=0.jpg @ 2019-11-22 01:35:16
[[file:%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2019-11-22_01-35-15_u=3544756367,1523761064&fm=26&gp=0.jpg]]
**** 文
+ client端的默认收集器
+ 最早的收集器,单线程进行GC
+ NeW和O|d generation都可以使用
+ 在新生代,采用复制算法;在老年代( *存活对象多，复制开销因而大*)采用Mark-Compact算法
+ 因为是单线程GC,没有多线程切换的额外开销,简单实用
*** ParNew
+ Serial收集器在新生代的多线程版本
+ 使用复制算法(因为针对新生代)
+ 只有在多CPU的环境下,效率才会比 Seria收集器高
+ 可以通过 -XX: ParallelGCThreads来控制GC线程数的多少。需要结合具体CPU的个数
+ Server模式下 *新生代* 的缺省收集器
*** Parallel Scavenge
Para|lel Scavenge收集器也是一个多线程收集器,也是使用复制算法,但它的对象分配规则与回收策略都与 ParNew收集器有所不同,它是以 *吞吐量最大化(即GC时间占总运行时间最小)* 为目标的收集器实现, *允许用较长时间的STW换取总吞吐量最大化* 
*** Seria|Old
SerialOld是单线程收集器,使用 *标记一整理算法*,是 *老年代的收集器*
*** ParallelOld
老年代版本吞吐量优先收集器,使用 *多线程* 和 *标记一整理算法*,JWM1.6提供,在此之前,如果新生代使用了PS收集器的话,老年代除 Serial old外别无选择,因为PS无法与CMS收集器配合工作
+ Parallel Scavenge+ Parallel old=高吞吐量,但GC停顿可能不理想
*** CMS
+ [[https://github.com/cncounter/gc-handbook/blob/master/04_GC_Algorithms_Implementations_CN.md]参考]
+ 目标 : GC效率可能不高,但stop-the-world最短，适合online应用，web也算
+ 适用场景 : 注重响应速度的服务
+ 只针对老年代, 一般结合ParallelNew使用
+ 回收算法 : 标记-清除
+ 清除的含义，在用空闲列表维护的内存中，被清除就是添加到空闲列表中，被认为是空的
+ 备胎回收器 : 相当于+XX:UseSerialGC,即新（存疑）老都是
+ i-cms : 增量cms已经不推荐使用，stw阶段与用户线程交替执行

**** 四步算法步骤
1. 初始标记(STW) : 标记GCRoot能直接关联的对象，以及新生代引用的对象以及新生代引用的对象
2. 并行标记 : 对外提供服务，继续向下标记，这步容忍有偏差
3. 重新标记(STW) : 修正偏差
4. 并发清除 : 因为这步要并行做，所以无法避免浮动垃圾

**** 7步详细步骤，帮助理解log
[[https://www.cnblogs.com/littleLord/p/5380624.html][详细步骤参考---说人话版本]]
[[https://www.jianshu.com/p/ba768d8e9fec][人话进阶版]]
[[https://blogs.oracle.com/poonam/understanding-cms-gc-logs][外国人版本-上古CMS]]
1. Phase 1: Initial mark
   + STW
   + 标记GCRoot能直接关联的对象
   + 以及新生代引用的对象
   + 对应log :[GC [1 CMS-initial-mark: 26386K(786432K)] 26404K(1048384K), 0.0074495 secs]   表示cms-initial-mark：开始于老年代占用是26386k，老年代总空间是786432k,后面的26404K(1048384K), 表示当前整个堆的内存使用情况和本次初始标记耗费的时间

2. Phase 2: Concurrent mark
   + 从第一步标记的对象出发，并行标记所有老年代存活对象
   + 完成时标记可能有偏差，为了保证程序正确执行，必须找到所有活的，包括在并行标记时偷偷又活过来的，可以放过在并行时悄悄死的，3-5步为了完成这个目标
   + 简单的，对象引用发生变化时，标记该对象所在区域为dirty card
   + log : [CMS-concurrent-mark-start]
3. Phase 3: Concurrent preclean
   + 处理应用程序第二阶段并行时新生成的从新生代指向老年代对象的引用，救活这个被引用的对象（也包括直接分配到老年代的对象）。
   + 扫描dirtyCard找到在第二阶段并行时，老年代发生关系变化的对象所在的card，把card中所有对象引用到的对象救活。
   + log : [CMS Concurrent-preclean
4. Phase 4: Concurrent abortable preclean
   + log : [CMS-concurrent-abortable-preclean
   + 为什么叫abortable？ 这个阶段是重复的做相同的事情直到发生aboart的条件（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。
   + 此阶段可能显著影响STW停顿的持续时间,并且有许多重要[[https://blogs.oracle.com/jonthecollector/entry/did_you_know][重要配置]]和失败模式。
   + *这个阶段实际上就是一个minorGC，用来减少新生代的对象，为下一阶段的Rescan减少压力*
   + 两个参数：CMSScheduleRemarkEdenSizeThreshold、CMSScheduleRemarkEdenPenetration，默认值分别是2M、50%。两个参数组合起来的意思是预清理后，eden空间使用超过2M时启动可中断的并发预清理（CMS-concurrent-abortable-preclean），直到eden空间使用率达到50%时中断，进入remark阶段。
   + 参数CMSMaxAbortablePrecleanTime ，默认为5S，最后的中断时间。中断这次minorGC，就算没有开始，也中断了，这就有可能没有minorGC就进入下一阶段了。
   + CMSScavengeBeforeRemark参数，使remark前强制进行一次Minor GC。解决上一条的问题，但是新生代如果垃圾特别少，这强加的一次GC显然得不偿失。
5. Phase 5: Final remark
   + STW来做最后的标记，准确的标记老年代所有活的对象,尽管先前的pre clean阶段尽量应对处理了并发运行时用户线程改变的对象应用的标记，但是不可能跟上对象改变的速度，只是为final remark阶段尽量减少了负担。
   + 重新标记的时候是要rescan新老分区的
   + CMS尽可能的尝试在新生代为空的时候进入Final remark阶段
6. Phase 6: Concurrent Sweep
   + 并行回收空间，这步应该是清理5阶段标记出来的已死对象，此阶段新生成的对象不在第五阶段的标活或标死里，不对新对象进行清扫。
7. Phase 7: Concurrent reset
   + 重置CMS算法相关的内部数据, 为下一次GC循环做准备


**** 3个缺点
1. 以尽量并发的方式来满足低停顿，即尽量GC线程和用户线程同时跑，会与服务争夺cpu，CMS默认的回收线程数是(CPU个数+3)/4，这是为了保证多核情况下，cm不会使用太少cpu，但是这导致cpu少的时候，cms会占用非常多的cpu资源。
2. 无法避免浮动垃圾，浮动垃圾是一种引起concurrent-mode-failure的原因。垃圾回收线程与用户线程并行时，老年代需要预留担保内存（CMSInitiatingOccupancyFraction，默认92%）来尽可能减少concurrent Mode Failure
3. 产生大量空间碎片，为此我们不得不选择一种策略(UseCMSCompactAtFullCollection或CMSFullGCsBeforeCompaction)做compaction,然而compaction是需要STW的

**** final remark阶段的详细解读
1. [Rescan (parallel) , 0.0103714 secs]这是整个final remark阶段扫描对象的用时总计，该阶段会重新扫描CMS堆中剩余的对象，重新从“根对象”开始扫描，并且也会处理对象关联。本次扫描共耗时 0.0103714s。
2. [weak refs processing, 0.0006267 secs]第一个子阶段，表示对弱引用的处理耗时为0.0006267s。

3. [class unloading, 0.0368915 secs]第二个子阶段，表示卸载无用的类的耗时为0.0368915s。

4. [scrub symbol table, 0.0486196 secs]最后一个子阶段，表示清理分别包含类级元数据和内部化字符串的符号和字符串表的耗时。

5. [1 CMS-remark: 108093K(126116K)]表示经历了上面的阶段后老年代的内存使用情况。再后面的132398K(165412K), 0.1005635 secs表示final remark后整个堆的内存使用情况和整个final remark的耗时。

*** G1 – Garbage First
[[https://tech.meituan.com/2016/09/23/g1.html][参考]]
**** 参数 
+ -XX:+UseG1GC
+ -XX:G1HeapRegionSize ：设置region大小，取值范围从1M到32M，且是2的指数，如果不设定，那么G1会根据Heap大小自动决定
#+BEGIN_SRC c
  // share/vm/gc_implementation/g1/heapRegion.cpp
  // Minimum region size; we won't go lower than that.
  // We might want to decrease this in the future, to deal with small
  // heaps a bit more efficiently.
  #define MIN_REGION_SIZE  (      1024 * 1024 )
  // Maximum region size; we don't go higher than that. There's a good
  // reason for having an upper bound. We don't want regions to get too
  // large, otherwise cleanup's effectiveness would decrease as there
  // will be fewer opportunities to find totally empty regions after
  // marking.
  #define MAX_REGION_SIZE  ( 32 * 1024 * 1024 )
  // The automatic region size calculation will try to have around this
  // many regions in the heap (based on the min heap size).
  #define TARGET_REGION_NUMBER          2048
  void HeapRegion::setup_heap_region_size(size_t initial_heap_size, size_t max_heap_size) {
    uintx region_size = G1HeapRegionSize;
    if (FLAG_IS_DEFAULT(G1HeapRegionSize)) {
      size_t average_heap_size = (initial_heap_size + max_heap_size) / 2;
      region_size = MAX2(average_heap_size / TARGET_REGION_NUMBER,
                         (uintx) MIN_REGION_SIZE);
    }
    int region_size_log = log2_long((jlong) region_size);
    // Recalculate the region size to make sure it's a power of
    // 2. This means that region_size is the largest power of 2 that's
    // <= what we've calculated so far.
    region_size = ((uintx)1 << region_size_log);
    // Now make sure that we don't go over or under our limits.
    if (region_size < MIN_REGION_SIZE) {
      region_size = MIN_REGION_SIZE;
    } else if (region_size > MAX_REGION_SIZE) {
      region_size = MAX_REGION_SIZE;
    }
  }
#+END_SRC

**** 设计理念
+ 面向多核大内存的服务器垃圾回收
+ 将回收代价分摊，将STW停顿的时间和分布变成可预期以及可配置的(取决于选择多少老年小堆参与回收),不必每次gc都全局扫描，而是增量的处理
+ 将大堆分成小堆,物理上分散，逻辑上分代.内存的使用更加灵活
+ 垃圾优先 : 所有小堆区按所包含的垃圾对象比例rank，每次回收垃圾多的老年代小堆和所有新生代小堆
+ g1更像一个实时回收器
**** region 角色
+ eden
+ survivor
+ old
+ Humongous  : 存大对象,超过region_size/2的对象
  + 直接分配到old代，防止没必要的来回拷贝
  + *H-obj在global concurrent marking阶段的cleanup 和 full GC阶段回收*
  + *在分配H-obj之前先检查是否超过 initiating heap occupancy percent和the marking threshold, 如果超过的话，就启动global concurrent marking，为的是提早回收，防止 evacuation failures 和 full GC*
  + TODO 连续的H-Obj分配对GC有什么影响

**** 实践
+ 设置-Xmn
  + 导致gc目标失效
  + 导致新生代大小不再可动态调节

**** CS
**** RS : 记录的是指向我的region（包括新老吧？）的地址么(应该不是对象的地址吧？)
**** 三色标记算法
+ 黑色:根对象,或者该对象与它的子对象都被扫描过(对象被标记了,且它的所有feld也被标记完了)
+ 灰色:对象本身被扫描,但还没扫描完该对象中的子对象(它的 field还没有被标记或标记完)
+ 白色:未被扫描对象,扫描完成所有对象之后最终为白色的为不可达对象,即垃圾对象(对象没有被标记到)
***** 问题
+ 在并发标记阶段，有可能因为应用程序的运行而导致指针改变，产生漏标问题。
+ 使用SATB来解决
**** SATB
全称是Snapshot-At-The-Beginning，用来解决误杀问题
1. 标记之前做一个活的对象的快照。之后就算是真死了也暂时不管
2. 标记完成后，看一下快照有没有增加新的引用，新引用的对象要标灰色
3. 很大几率加深浮动垃圾(这个机制很有可能救了一堆不该救的人)
**** global concurrent marking
1. 初始标记
2. 并发标记
3. 重新标记
4. 并发清楚已死的
**** 和Card
**** G1的收集模式
***** Young GC
***** Mixed GC
***** note
+ 初始标记是在 Young GC上执行的,在进行全局并发标记的时候不会做Mixed gc,在做MixedGC的时候也不会启动初始标记阶段。
+ G1的运行过程是这样的:会在 Young GC和Mixed gc之间不断地切换运行,同时定期地做全局并发标记,在实在赶不上对象创建速度的情况下使用Full GC( Serial gc)

** 内存分配
+ 堆上分配 : 大多数分配至eden区，偶尔分在old
+ 栈上分配 : 原子类型的局部变量
** 内存泄漏
*** 产生原因
**** 对象定义在错误的范围 (Wrong Scope)
#+BEGIN_SRC java
  //一段代码
  class Foo{
      private string[] names;
      public void doIt(int length){
          if (names = null II names.length < length)
              names new string[length];
          populate( names);
          print(names);
      }
  }
#+END_SRC
+ 如上面这段代码，变量names声明在方法外部，假如我们只会在这个方法中使用names，且foo类生命周期非常长，那么name对象由于一直有一个引用，所以对象所占这部分内存就被偷了，改成如下代码
#+BEGIN_SRC java
  class Foo {
      public void doIt(int length) {
          String[] names = new String [length]i
              populate( names);
          print(names);
      }
  }
#+END_SRC
**** 异常( EXception)处理不当
#+BEGIN_SRC java
  //连接泄露
  Connection conn DriverManager getConnection(url, name, passwd);
  try {
      String sgl ="do a query sql";
      Preparedstatement stmt = conn. preparestatement(sql);
      Resultset rs = stmt. executequery();
      while (rs.next()){
          dosomestuff();
      }
      //主要看这里
      rs close();
      conn close();
  } catch (Exception e){
  }
#+END_SRC
+ 如果 doSomestuff()抛出异常,rg.close和cnn.close不会被调用,会导致内存泄漏和连接泄漏,改正如下
#+BEGIN_SRC java
  Preparedstatement stmt null;
  Resultset rs = null;
  try {
      string sql ="do a query sql";
      stmt conn. preparestatement(sql);
      rs stmt executequery;
      while (rs.next()){
          dosomestuff();
      }
  }catch (Exception e) {
      // handle exception
  } finally {
      //永远用finally去关闭资源,避免资源泄漏
      if (rs != null){
          rs.close();
      }
      if (stmt ! null){
          stmt. close();
      }
      conn close();
  }
#+END_SRC
**** 集合数据管理不当
** jvm write barrier
[[http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html][大神，G1的write barrier没看完]]
用于GC中的一些统计数据，比如RS，CS
#+begin_quote
Barriers can be implemented in either software or hardware. Software barriers involve additional instructions around load or store operations, which would typically be added by a cooperative compiler. Hardware barriers don’t require compiler support, and may be implemented on common operating systems by using memory protection.
#+end_quote
我们知道，java中，value store这个操作对原生类型和引用类型是不一样的。
*** OOP
Ordinary Object Pointer对应于JMM
*** 用途
+ 用于 card marking
+ 用于 RS和CS
*** 分代回收带来跨代引用问题
假设一个对象x只有从老年代中的对象对x的引用，name按照GC root和trace的定义，x将被回收。但明显x是不应该被回收的。card marking 用于解决这个问题。
*** card marking
java把heap分成一组card，每个card略小于内存页。jvm维护一个Map<card> dirtyCard,每当heap中的一个对象的一个引用（pointer）字段（属性）被修改时，都会有这个对象所在的card对应于Map中的一个bit被设置（为0），表示这个card中的对象引用有变化
#+begin_example
设每个card的大小为512bit，this为改变的引用关系中的发起者，则有：
CARD_TABLE [this address >> 9] = 0;
#+end_example
**** 牺牲
在代码看来，这样每当有引用类型的赋值时，都会现有一个marking card 的操作，然后才是赋值。这是必要的牺牲。
*** condition card marking
同一个card中的多个对象的引用字段发生变化时，不必每次都设置Map<card> dirtyCard中的对应标志
#+begin_example
设每个card的大小为512bit，this为改变的引用关系中的发起者，则有：
if (CARD_TABLE [this address /512] != 0) CARD_TABLE [this address >> 9] = 0; 
#+end_example
*** G1中的表现
* GC参数
** 调试常用参数
#+begin_example
  -verbose:gc
  -Xms20M
  -Xmx20M
  -Xmn10M
  -XX:+PrintGCDetails
  -XX:SurvivorRatio=8
  -XX:PretenureSizeThreshold=4194304
  -XX:+UseSerialGC
#+end_example
+ -XX:MaxTenuringThreshold=5  : 晋升年龄的最大值，也就是有可能在小于5的时候就晋升，该参数的默认值为15,CMS中默认值为6,G1中默认为15(在JVM中,该数值是由4个bit来表示的,所以最大值1111,即15). 经历了多次Gc后,存活的对象会在 From Survivor与 To Survivor之间来回存放,而这里面的一个前提则是这两个空间有足够的大小来存放这些数据,一种策略是计算每个年龄对象的大小,如果达到某个年龄后发现总大小已经大于了 Survivor空间的50号,那么这时就需要调整阈值,不能再继续等到默认的15次gc,因为这样会导致 Survivor空间不足,所以需要调整阈值,让这些存活对象尽快完成晋升。
** GC-log
含义解析样例
+ 正常gc
#+begin_example

  [ GC (Allocation Failure)[PSYoungGen: 5646K->624K(9216K)] 5646K->4728K(19456K),0.0044403 secs] [Times: user=0.03 sys=0.00, real=0.01 secs
  [ GC                   是什么GC? 是minorGC，如果是FullGC会显示FullGC
  (Allocation Failure)  GC的原因是？Allocation failure 分配内存后达到新生代设置的GC阈值，这里意为尚可分配，但是有点挤了。若压根分配不开，会直接在老年代分配
  [PSYoungGen:	本次会收使用什么垃圾收集器？ 分代parallel scavenge      
  5646K->624K(9216K)] 			     具体的，回收前新生代被使用了5646k，回收后新生代被使用624k，总的新生代可用空间9216k(配置定死的)
  5646K->4728K(19456K),		     回收前总的被使用的堆5646k，回收后总的堆被使用4728k，总堆可用大小为19456（配好的）
  0.0044403 secs] [Times: user=0.03 sys=0.00, real=0.01 secs	总共用了0.0044403秒，其中用户空间糊了0.03秒，内核空间几乎是0.00，真正运行了0.01秒
#+end_example

+ full GC
#+begin_example
  [Full GC (Ergonomics) [PSYoungGen: 608K->0K(9216K)] [ParOldGen: 5128K->5616K(10240K)] 5736K->5616K(19456K), [Metaspace: 3290K->3290K(1056768K)], 0.0057821 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
  [Full GC
  (Ergonomics)		GC本身需要的一次GC
  [PSYoungGen: 608K->0K(9216K)]	新生代回收到0了
  [ParOldGen: 5128K->5616K(10240K)] 5736K->5616K(19456K),// 回收前5128k，回收后5616k，老年代总共10240k，后面的一对数为对空间回收前后的值，堆总大小为19456k
  [Metaspace: 3290K->3290K(1056768K)], //元空间在GC前后的变化
  0.0057821 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
#+end_example

+ Full GC - another version
#+begin_example
2020-05-25T22:32:30.549+0800: 30.993: [Full GC (GCLocker Initiated GC) 2020-05-25T22:32:30.549+0800: 30.993: 
[CMS: 3086306K->3086306K(3086784K), 0.6462093 secs] 4082949K->3768837K(4083584K), // 回收前后
[Metaspace: 37917K->37917K(1083392K)], 0.6462875 secs] [Times: user=0.65 sys=0.00, real=0.64 secs]

#+end_example
** 查看虚拟机默认参数
#+BEGIN_SRC sh
  java -XX:+PrintCommandLineFlags -version
#+END_SRC

+ -XX:+UseCompressedOops : 指针膨胀时压缩
+ -XX:+UseParallelGC：新生代用Parallel scavenge 老年代用 parallel old
** -XX:UseSerialGC 
+ -XX:PretenureSizeThreshold=<字节为单位的一个数> : 老年代预备役的大小，超过这个值将直接分配在老年代

** XX:+UseStringDeduplication
+ 限制
  1. 只适用于G1
  2. 只适用于长期存活的对象，-XX:StringDeduplicationAgeThreshold=6，默认是3, 表示一个string对象经过几次GC为长期存活
  3. 可能会增加GC时间，因为有附加的清除重复字符串的工作，但影响可能是减少随后的GC频率和随后的GC过程中扫描的负担
+ -XX:+PrintStringDeduplicationStatistics查看去重信息
* OOM
[[https://www.cnblogs.com/intsmaze/p/9550256.html][为什么使用dump而不是报错日志]]

todo 
1. 排查内存溢出
** 生成dump文件的集中方式
1. jmapdump
2. jconsole HotSpotDiagnosticMXBean
3. jvm参数
   1) -XX:+HeapDumpOnOutOfMemoryError
   2) -XX:HeapDumpPath=/home/wangchao/brfs/dump
4. hprof 命令，查看cpu和内存
   1. [[http://docs.oracle.com/javase/8/docs/technotes/samples/hprof.html][参考]]


* 线程状态
[[https://www.uml-diagrams.org/java-thread-uml-state-machine-diagram-example.html][参考]]

#+DOWNLOADED: https://www.uml-diagrams.org/examples/state-machine-example-java-6-thread-states.png @ 2019-12-08 18:28:57
[[file:%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/2019-12-08_18-28-55_state-machine-example-java-6-thread-states.png]]

* waiting状态的线程被唤醒的时候进入blocked状态
#+DOWNLOADED: https://www.uml-diagrams.org/examples/state-machine-example-java-6-thread-states.png @ 2019-11-20 11:13:33
[[file:%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/2019-11-20_11-13-33_state-machine-example-java-6-thread-states.png]]
* 类加载
- 在类被首次主动使用时才会类的初始化
- 但并没有延迟加载，即类的加载在首次主动使用前就完成了，不过如果加载失败，这个错误信息要等到首次主动使用才会抛出(延迟抛出)
- 当一个类初始化的时候，它所实现的接口是不会被初始化的
- classloader去load一个类的时候不会导致类的初始化，只有用反射class.forname的时候才会初始化


** 自定义类加载器
*** 场景
1. 冲突隔离
2. 热加载
3. 代码保护
** 双亲委托机制
*** 为啥？
为了防止恶意代码，比如Object类只能有启动加载器加载，即使其它加载器想要加载Ojbect或者修改的Object类，都最终会委托给启动加载器，然后就会被发现是恶意的
*** 上下文加载器
为了破坏双亲委托机制
使得父类可以使用子类的加载器
**** 使用模式
- 获取
- 替换
- 还原
* 字节码
* 内存结构
- Hotspot中方法栈和JNI方法栈是同一个
* 主要组件和架构
- 执行引擎
  - GC
  - JIT
* 工具
** jvisualvm
- poid 优先级
- 线程dump
- 堆dump
- Metaspace监控
** jconsole
- 线程监控可以看到线程的总等待、总阻止线程数
- 检查死锁的线程
- HotSpotDiagnosticMXBean ： 生成内存快照
** jmap
- clstat : 查看类加载器的统计数据
- heapheap : 堆和gc的统计数据
- jmap -dump:file=3.dump 19076 : 生成内存快照
- -histo : 内存直方图
** jstat
- gc gc统计信息
  - MC : current metaspace capacity  （KB）
  - MU : metaspace Utillization 已用空间
- jstat -gc -t <pid> 1s : 这个命令有歧义
** jcmd (1.7新增的)
- jcmd <pid> help ： 看一下可以对这个进程做什么
- jcmd <pid> help <具体命令> : 具体命令的帮助
- jcmd <pid> VM.flags : 查看jvm启动参数
- jcmd <pid> PerfCounter.print : 统计jvm性能
- jcmd <pid> VM.uptime : 这个jvm启动多长时间了
- jcmd <pid> GC.class_histogram : 类的统计信息  可以用head查看前几行
- jcmd <pid> Thread.print : 线程堆栈信息，grep deadlock 看有没有死锁及死锁的详细信息
- jcmd <pid> GC.heap_dump <目标文件> : 导出dump文件，然后用jvisualvm装载(打开gui>菜单栏>装入文件)文件分析，heap dump会导致程序暂停一下
- jcmd <pid> VM.system_properties : 查看jvm的信息，也就是 ps -ef 输出的那一大坨信息
- 获得命令行参数
- 获得jvm版本信息
** jstack
与jcmd pid Thread.print差不多，但jstack是专门获得线程堆栈信息的
- jstack <pid>
** jmc(java mission control)
- 与jcmd差不多，但是是实时的
- 可以jcmd生成JFR(java fligh recorder:飞行记录器)文件
** jhat
**** 可以转储dump文件
**** 可以分析dump文件(没有图形界面的时候用)
1. 可以按条件查询，比如查询某个class的所有实例

** heapHore
** gceasy
** top
查看cpu到底在干什么
1. 使用top命令查找CPU使用率最高的进程

2. top -H -p pid 找到CPU使用率最高的线程(-H 线程模式)

3. printf “%x\n” tid 把线程ID输出为16进制(java 中线程nid(16进制)-->linux 中tid(10进制))

4. jstack pid | less 从中模式匹配nid，查看对应代码

