#+title: jvm
* hotspot由来
JIT编译器在运行时创建方法使用文件，然后一步一步的优化每一个方法，有时候会主动的优化应用的行为。这些优化技术，比如积极的分支预测（optimistic branch prediction），如果不先分析应用就不能有效的使用。这样将频繁调用的部分提取出来，编译成本地代码，也就是在应用中构建某种热点（即HotSpot，这也是HotSpot JVM名字的由来）。使用
* jvm类型
以下两种是不同的虚拟机
** client
** server
具备更高级的优化算法的虚拟机
* jvm工作模式
** -Xint
强制JVM以解释方式执行所有的字节码
** -Xcomp
JVM在第一次使用时会把所有的字节码编译成本地代码
** -Xmixed
对于字节码中多次被调用的部分，JVM会将其编译成本地代码以提高执行效率；而被调用很少（甚至只有一次）的方法在解释模式下会继续执行，从而减少编译和优化成本
** 代码中获取jvm工作模式
#+begin_src java
  System.out.println(System.getProperty("java.vm.name")); //获取JVM名字和类型
  System.out.println(System.getProperty("java.vm.info")); //获取JVM的工作模式
#+end_src

* 垃圾回收
** 简介
+ 垃圾收集器跟踪所有正在使用的对象,并把其余部分当做垃圾
+ 第一款垃圾收集器是1959年为Lisp语言开发的, 此后 Lisp 的垃圾收集技术也一直处于业界领先水平。
** 基本概念
*** mutator
用来指应用程序
*** collector
用来指回收器
*** a long-standing untest concept
死掉的对象是没法活过来的
*** 垃圾回收的评价标准
**** 吞吐量
单位时间里的处理能力
**** latency
暂停mutator的时间
**** 堆使用效率
例如，标记一整理算法总会在堆中保留一个连续的空白区域。它相较于标记清楚算法而言，在堆的使用率上面就会显得比较低
**** 访问的局部性
相关联的对象一般会更可能被连续访问，这就是访问的局部性。所以如果一个GC算法能够将相关的对象重排在一起，那对于mutator的来说，访问起来就非常丝滑了
** STW 存在的必要性
垃圾收集过程中, 需要暂停应用程序的所有线程。假如不暂停,则对象间的引用关系会一直不停地发生变化, 那样就没法进行统计了
** 回收位置
+ heap : 回收性价比高
+ 方法区 : 虚拟机规范没有要求，商用虚拟机都实现了(回收废弃 *常量* 和 *无用的类*)
  + 类回收的条件（非常苛刻、证类无用）
    1. 任何该类的实例都已经被回收
    2. 加载该类的classloader已经被GC
    3. 该类对应java.lang.class对象没有在任何地方被引用，且不存在任何可以通过反射访问该类的方法
  + 需要关注方法区垃圾回收（类卸载）的场景
    + 大量使用反射、动态代理、CGlib等字节码生成工具
    + OSGI类的频繁自定义classloader的场景
    + 动态生成jsp
** 回收算法（分段式如何保证回收事务？）
*** 标记清除(保守式GC，不移动对象)
  + 标记会stw
  + 清除(不整理)效果不好，内存碎片问题
  + 遍历整个堆，所以消耗时间与堆大小成正比
**** 空闲链表
在清除阶段，把不可达的对象作为分块链接到空闲链表。这里涉及到该对象的头(地址和size)，域(next指向空闲链表中的下一个回收对象)
***** mutator在空闲链表中选择空间来分配新对象时
可以指定一些策略，如
1. first-fit：找到第一个满足大小的块就返回
2. best-fit：找到满足大小且最小的块返回
3. worst-fit: 找到满足大小且最大的块返回
**** 优化
***** 清除阶段尽可能的合并小分块
具体的，如果发现此次清除的分块与上一个清除的分块是连续的，那么把他们合并成一个大块
***** 多个空闲链表
把大分块和小分块分到不同的空闲链表管理，这样在分配的时候，可以根据size加速分配过程
**** 缺点
***** 与写时复制(copy-on-write)不兼容
写时复制：在linux中复制(fork)进程，并不会直接复制该进程的内存空间，而是共享内存空间，只有当进程对内存有写操作时才会真正的复制内存空间，而标记-清除算法，即使mutator没有重写对象，GC也会重写标志位，造成不必要的复制

*** 标记整理
  + 整理过程会移动对象，这样，就需要更新指向这个对象的引用，这是一个stw过程，停顿但是安全，这就是为什么CMS尽量不整理
+ 复制算法(空间换时间)
  + 现在的商用jvm都才用 **复制算法*实现新生代*
  + hostSpot ： eden区 : survivor区 = 8 : 1 : 1 (survivor个数可以设置)
  + 优点是标记和复制可以同时做
  + 效率不一定高：正向作用是只需要扫描存活的对象，逆向作用是额外多一次复制操作，在存活率高的情况下放大逆向作用
  + *由于上述原因，复制算法适用于系统中会有大量生命周期特短的对象*
+ 分代算法
  + 分代也存在问题，即回收一个分代时，另一个分代中的所有对象都称为GC root，使用 *card-marking* 解决这个问题，[[http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html][参考]]
  + 适合的场景 : 系统中大部分对象要么活得长，要么死的快
** 垃圾回收算法
*** 问题
1. 高速缓存如何影响collector性能？ 答：一旦算法没有利用上locality，那么它将失去高速缓存带来的预取或者批量的特性
2. 堆的可遍历性，有无填充字节要怎么遍历？
** 死亡鉴定
没有引用即为死
*** 四种引用类型
+ hbase用了 *软引用* 和 *弱引用* 的pool
+ 强引用：声明赋值的引用，只要有强引用指着，内存不够也不回收，oom
+ 软引用：留校察看的引用，引用的对象只有在内存不够的时候才回收
+ 弱引用：只要发生GC，弱引用关联的对象都会被回收
+ 虚引用(Phantom)
+ 引用队列 : 可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。
  
** 判活的方法
*** 引用计数
+ 缺点 ： 需要额外判断循环引用
+ Objective-C 使用引用计数
*** 可达性分析
+ java 、 c#
**** java中的GC root？
gcroot分两类
1. 生命周期很长的对象，比如类的静态变量(方法区中的静态引用、常量)
2. 一定有用的对象，比如栈帧(包括本地方法栈)的局部变量
** 垃圾回收的定义
*** minor GC
+ 用于回收eden区
+ 触发时机 : 新对象生成后判断一下更新的eden区的使用情况，放不下的时候呢？
*** full GC
+ 对整个JVM进行整理(young、old、perm)
+ 触发时机
  + Old满了
  + perm满了
  + system.gc()建议gc
** 垃圾回收器
*** 总览
#+DOWNLOADED: file:/Users/wangchao/Desktop/截屏2019-11-22上午1.13.48.png @ 2019-11-22 01:16:22
[[file:%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2019-11-22_01-16-22_%E6%88%AA%E5%B1%8F2019-11-22%E4%B8%8A%E5%8D%881.13.48.png]]
*** Serial
**** 图
#+DOWNLOADED: https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3544756367,1523761064&fm=26&gp=0.jpg @ 2019-11-22 01:35:16
[[file:%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2019-11-22_01-35-15_u=3544756367,1523761064&fm=26&gp=0.jpg]]
**** 文
+ client端的默认收集器
+ 最早的收集器,单线程进行GC
+ NeW和Old generation都可以使用
+ 在新生代,采用复制算法;在老年代( *存活对象多，复制开销因而大*)采用Mark-Compact算法
+ 因为是单线程GC,没有多线程切换的额外开销,简单实用
*** ParNew
+ Serial收集器在新生代的多线程版本
+ 使用复制算法(因为针对新生代)
+ 只有在多CPU的环境下,效率才会比 Seria收集器高
+ 可以通过 -XX: ParallelGCThreads来控制GC线程数的多少。需要结合具体CPU的个数
+ Server模式下 *新生代* 的缺省收集器
*** Parallel Scavenge
Para|lel Scavenge收集器也是一个多线程收集器,也是使用复制算法,但它的对象分配规则与回收策略都与 ParNew收集器有所不同,它是以 *吞吐量最大化(即GC时间占总运行时间最小)* 为目标的收集器实现, *允许用较长时间的STW换取总吞吐量最大化* 
*** SerialOld
SerialOld是单线程收集器,使用 *标记一整理算法*,是 *老年代的收集器*
*** ParallelOld
老年代版本吞吐量优先收集器,使用 *多线程* 和 *标记一整理算法*,JWM1.6提供,在此之前,如果新生代使用了PS收集器的话,老年代除 Serial old外别无选择,因为PS无法与CMS收集器配合工作
+ Parallel Scavenge+ Parallel old=高吞吐量,但GC停顿可能不理想
*** CMS
+ [[https://github.com/cncounter/gc-handbook/blob/master/04_GC_Algorithms_Implementations_CN.md]参考]
+ 目标 : GC效率可能不高,但stop-the-world最短，适合online应用，web也算
+ 适用场景 : 注重响应速度的服务
+ 只针对老年代, 一般结合ParallelNew使用
+ 回收算法 : 标记-清除
+ 清除的含义，在用空闲列表维护的内存中，被清除就是添加到空闲列表中，被认为是空的
+ 备胎回收器 : 相当于+XX:UseSerialGC,即新（存疑）老都是
+ i-cms : 增量cms已经不推荐使用，stw阶段与用户线程交替执行

**** 四步算法步骤
1. 初始标记(STW) : 标记GCRoot能直接关联的对象，以及新生代引用的对象
2. 并行标记 : 对外提供服务，继续向下标记，这步容忍有偏差
3. 重新标记(STW) : 修正偏差
4. 并发清除 : 因为这步要并行做，所以无法避免浮动垃圾

**** 7步详细步骤，帮助理解log
[[https://www.cnblogs.com/littleLord/p/5380624.html][详细步骤参考---说人话版本]]
[[https://www.jianshu.com/p/ba768d8e9fec][人话进阶版]]
[[https://blogs.oracle.com/poonam/understanding-cms-gc-logs][外国人版本-上古CMS]]
1. Phase 1: Initial mark
   + STW
   + 标记GCRoot能直接关联的对象,所以你知道啥是gc root不？
   + 以及新生代引用的对象
   + 对应log :[GC [1 CMS-initial-mark: 26386K(786432K)] 26404K(1048384K), 0.0074495 secs]   表示cms-initial-mark：开始于老年代占用是26386k，老年代总空间是786432k,后面的26404K(1048384K), 表示当前整个堆的内存使用情况和本次初始标记耗费的时间

2. Phase 2: Concurrent mark
   + 从第一步标记的对象出发，并行标记所有老年代存活对象
   + 完成时标记可能有偏差，为了保证程序正确执行，必须找到所有活的，包括在并行标记时偷偷又活过来的，可以放过在并行时悄悄死的，3-5步为了完成这个目标
   + 简单的，对象引用发生变化时，标记该对象所在区域为dirty card
   + log : [CMS-concurrent-mark-start]
3. Phase 3: Concurrent preclean
   + 处理应用程序第二阶段并行时新生成的从新生代指向老年代对象的引用，救活这个被引用的对象（也包括直接分配到老年代的对象）。
   + 扫描dirtyCard找到在第二阶段并行时，老年代发生关系变化的对象所在的card，把card中所有对象引用到的对象救活。
   + log : [CMS Concurrent-preclean
4. Phase 4: Concurrent abortable preclean
   + log : [CMS-concurrent-abortable-preclean
   + 为什么叫abortable？ 这个阶段是重复的做相同的事情直到发生aboart的条件（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。
   + 此阶段可能显著影响STW停顿的持续时间,并且有许多重要[[https://blogs.oracle.com/jonthecollector/entry/did_you_know][重要配置]]和失败模式。
   + *这个阶段实际上就是一个minorGC，用来减少新生代的对象，为下一阶段的Rescan减少压力*
   + 两个参数：CMSScheduleRemarkEdenSizeThreshold、CMSScheduleRemarkEdenPenetration，默认值分别是2M、50%。两个参数组合起来的意思是预清理后，eden空间使用超过2M时启动可中断的并发预清理（CMS-concurrent-abortable-preclean），直到eden空间使用率达到50%时中断，进入remark阶段。
   + 参数CMSMaxAbortablePrecleanTime ，默认为5S，最后的中断时间。中断这次minorGC，就算没有开始，也中断了，这就有可能没有minorGC就进入下一阶段了。
   + CMSScavengeBeforeRemark参数，使remark前强制进行一次Minor GC。解决上一条的问题，但是新生代如果垃圾特别少，这强加的一次GC显然得不偿失。
5. Phase 5: Final remark
   + STW来做最后的标记，准确的标记老年代所有活的对象,尽管先前的pre clean阶段尽量应对处理了并发运行时用户线程改变的对象应用的标记，但是不可能跟上对象改变的速度，只是为final remark阶段尽量减少了负担。
   + 重新标记的时候是要rescan新老分区的
   + CMS尽可能的尝试在新生代为空的时候进入Final remark阶段
6. Phase 6: Concurrent Sweep
   + 并行回收空间，这步应该是清理5阶段标记出来的已死对象，此阶段新生成的对象不在第五阶段的标活或标死里，不对新对象进行清扫。
7. Phase 7: Concurrent reset
   + 重置CMS算法相关的内部数据, 为下一次GC循环做准备


**** 3个缺点
1. 以尽量并发的方式来满足低停顿，即尽量GC线程和用户线程同时跑，会与服务争夺cpu，CMS默认的回收线程数是(CPU个数+3)/4，这是为了保证多核情况下，cm不会使用太少cpu，但是这导致cpu少的时候，cms会占用非常多的cpu资源。
2. 无法避免浮动垃圾，浮动垃圾是一种引起concurrent-mode-failure的原因。垃圾回收线程与用户线程并行时，老年代需要预留担保内存（CMSInitiatingOccupancyFraction，默认92%）来尽可能减少concurrent Mode Failure
3. 产生大量空间碎片，为此我们不得不选择一种策略(UseCMSCompactAtFullCollection或CMSFullGCsBeforeCompaction)做compaction,然而compaction是需要STW的

**** final remark阶段的详细解读
1. [Rescan (parallel) , 0.0103714 secs]这是整个final remark阶段扫描对象的用时总计，该阶段会重新扫描CMS堆中剩余的对象，重新从“根对象”开始扫描，并且也会处理对象关联。本次扫描共耗时 0.0103714s。
2. [weak refs processing, 0.0006267 secs]第一个子阶段，表示对弱引用的处理耗时为0.0006267s。

3. [class unloading, 0.0368915 secs]第二个子阶段，表示卸载无用的类的耗时为0.0368915s。

4. [scrub symbol table, 0.0486196 secs]最后一个子阶段，表示清理分别包含类级元数据和内部化字符串的符号和字符串表的耗时。

5. [1 CMS-remark: 108093K(126116K)]表示经历了上面的阶段后老年代的内存使用情况。再后面的132398K(165412K), 0.1005635 secs表示final remark后整个堆的内存使用情况和整个final remark的耗时。

*** G1 – Garbage First
[[https://tech.meituan.com/2016/09/23/g1.html][参考]]
**** 参数 
+ -XX:+UseG1GC
+ -XX:G1HeapRegionSize ：设置region大小，取值范围从1M到32M，且是2的指数，如果不设定，那么G1会根据Heap大小自动决定
#+BEGIN_SRC c
  // share/vm/gc_implementation/g1/heapRegion.cpp
  // Minimum region size; we won't go lower than that.
  // We might want to decrease this in the future, to deal with small
  // heaps a bit more efficiently.
  #define MIN_REGION_SIZE  (      1024 * 1024 )
  // Maximum region size; we don't go higher than that. There's a good
  // reason for having an upper bound. We don't want regions to get too
  // large, otherwise cleanup's effectiveness would decrease as there
  // will be fewer opportunities to find totally empty regions after
  // marking.
  #define MAX_REGION_SIZE  ( 32 * 1024 * 1024 )
  // The automatic region size calculation will try to have around this
  // many regions in the heap (based on the min heap size).
  #define TARGET_REGION_NUMBER          2048
  void HeapRegion::setup_heap_region_size(size_t initial_heap_size, size_t max_heap_size) {
    uintx region_size = G1HeapRegionSize;
    if (FLAG_IS_DEFAULT(G1HeapRegionSize)) {
      size_t average_heap_size = (initial_heap_size + max_heap_size) / 2;
      region_size = MAX2(average_heap_size / TARGET_REGION_NUMBER,
                         (uintx) MIN_REGION_SIZE);
    }
    int region_size_log = log2_long((jlong) region_size);
    // Recalculate the region size to make sure it's a power of
    // 2. This means that region_size is the largest power of 2 that's
    // <= what we've calculated so far.
    region_size = ((uintx)1 << region_size_log);
    // Now make sure that we don't go over or under our limits.
    if (region_size < MIN_REGION_SIZE) {
      region_size = MIN_REGION_SIZE;
    } else if (region_size > MAX_REGION_SIZE) {
      region_size = MAX_REGION_SIZE;
    }
  }
#+END_SRC
+ -XX:InitiatingHeapOccupancyPercent=45 回收oldregion 开始并发标记的阈值
+ -XX:MaxGCPauseMillis=0 gc暂停的目标时间，默认为0，等同于没配置
+ -XX:GCPauseIntervalMillis=200 gc最小间隔时间，g1会尽力不小于这个间隔
+ 设置-Xmn
  + 导致gc目标失效
  + 导致新生代大小不再可动态调节
**** 设计理念
1. 面向多核大内存（>=6G）的服务器低停顿（<=0.5s）垃圾回收
2. *停顿预测模型* 将回收代价分摊，将STW停顿的时间和分布变成可预期以及可配置的(取决于选择多少老年小堆参与回收),不必每次gc都全局扫描，而是增量的处理
3. 将大堆分成小堆,物理上分散，逻辑上分代.内存的使用更加灵活
4. *垃圾优先* : 所有小堆区按所包含的垃圾对象比例rank，每次回收垃圾多的老年代小堆和所有新生代小堆
5. g1更像一个实时回收器，但它还不是。啥是实时回收器？

**** if满足这些条件，then try g1 than cms
1. 存活对象超过50%
2. 对象分配率和晋升率差距很大，means that 大部分对象得不到晋升，很多短生对象
3. 想要试试低延迟
**** region 角色
+ eden
+ survivor
+ old
+ Humongous  : 存大对象,超过region_size/2的对象
  + 直接分配到old代，防止没必要的来回拷贝
  + *H-obj在global concurrent marking阶段的cleanup 和 full GC阶段回收*
  + *在分配H-obj之前先检查是否超过 initiating heap occupancy percent和the marking threshold, 如果超过的话，就启动global concurrent marking，为的是提早回收，防止 evacuation failures 和 full GC*
  + TODO 连续的H-Obj分配对GC有什么影响
**** G1的收集模式
***** Young GC
***** Mixed GC
***** note
+ 初始标记是在 Young GC上执行的,在进行全局并发标记的时候不会做Mixed gc,在做MixedGC的时候也不会启动初始标记阶段。
+ G1的运行过程是这样的:会在 Young GC和Mixed gc之间不断地切换运行,同时定期地做全局并发标记,在实在赶不上对象创建速度的情况下使用Full GC( Serial gc)
**** stw
g1的stw用来干什么？
1. copy live object
2. clean up 阶段
   1. 识别空region
   2. 挑选参与下一次回收的old region（mark？）
**** 三色标记算法
+ 黑色:根对象,或者该对象与它的子对象都被扫描过(对象被标记了,且它的所有feld也被标记完了)
+ 灰色:对象本身被扫描,但还没扫描完该对象中的子对象(它的 field还没有被标记或标记完)
+ 白色:未被扫描对象,扫描完成所有对象之后最终为白色的为不可达对象,即垃圾对象(对象没有被标记到)
***** 问题
+ 在并发标记阶段，有可能因为应用程序的运行而导致指针改变，产生漏标问题。
+ 使用SATB来解决

**** CS
**** Card table
hotspot vm和的gc 堆上都有一个Card Table
***** RS :
- 在一次增量回收中，我们需要知道那些从不参与回收的部分指向回收中的部分的引用，在分代算法中，这个数据结构是remembered set。
- card table是一种特殊的rs
***** G1 GC则是在points-out的card table之上再加了一层结构来构成points-into RSet
每个region会记录下到底哪些别的region有指向自己的指针，而这些指针分别在哪些card的范围内。这个RSet其实是一个hash table，key是别的region的起始地址，value是一个集合，里面的元素是card table的index。
***** 举例来说
如果region A的RSet里有一项的key是region B，value里有index为1234的card，它的意思就是region B的一个card里有引用指向region A。所以对region A来说，该RSet记录的是points-into的关系；而card table仍然记录了points-out的关系。
**** G1过程
***** collector
相互独立的两个步骤
****** global concurrent marking
是一个基于SATB的并发标记
******* SATB
全称是Snapshot-At-The-Beginning，用来解决误杀问题
1. 标记之前做一个包含所有活的对象的快照。也就是gc做这次快照之时活着的对象就算是存活对象，就算后面有死掉的（floating garbage），也不会在本次gc中回收它
2. 很容易知道哪些对象是一次GC开始之后新分配的，如何实现：每个region记录着两个top-at-mark-start（TAMS）指针，分别为prevTAMS和nextTAMS。在TAMS以上的对象就是新分配的，因而被视为隐式marked。
3. （存疑）标记完成后，看一下快照有没有增加新的引用，新引用的对象要标灰色

5. 注意 cms是incremental update而不是SATB
******** snapshot的定义 (how?)
SATB要维持“在GC开始时活的对象”的状态这个逻辑snapshot。除了从root出发把整个对象图mark下来之外，其实只需要用pre-write barrier把每次引用关系变化时旧的引用值记下来就好了。这样，等concurrent marker到达某个对象时，这个对象的 *所有引用类型字段的变化全都有记录在案* ，就不会漏掉任何在snapshot里活的对象。当然，很可能有对象在snapshot中是活的，但随着并发GC的进行它可能本来已经死了，但SATB还是会让它活过这次GC。
******* 1. initial marking
*暂停阶段* 扫描根集合，标记所有从根集合可直接到达的对象并将它们的字段压入扫描栈（marking stack）中等到后续扫描。G1使用外部的bitmap来记录mark信息，而不使用对象头的mark word里的mark bit。在分代式G1模式中，初始标记阶段借用young GC的暂停，因而没有额外的、单独的暂停阶段。
******* 2. concurrent marking
*并发阶段* 不断从扫描栈取出引用递归扫描整个堆里的对象图。每扫描到一个对象就会对其标记，并将其字段压入扫描栈。重复扫描过程直到扫描栈清空。过程中还会扫描SATB write barrier所记录下的引用。
******* 3. 最终标记（final marking，在实现中也叫remarking）
*暂停阶段* 在完成并发标记后，每个Java线程还会有一些剩下的SATB write barrier记录的引用尚未处理。这个阶段就负责把剩下的引用处理完。同时这个阶段也进行弱引用处理（reference processing）。注意这个暂停与CMS的remark有一个本质上的区别，那就是这个暂停只需要扫描SATB buffer，而CMS的remark需要重新扫描mod-union table里的dirty card外加整个根集合，而此时整个young gen（不管对象死活）都会被当作根集合的一部分，因而CMS remark有可能会非常慢。
******* 4. 清理（cleanup）：
*暂停阶段* 清点和重置标记状态。这个阶段有点像mark-sweep中的sweep阶段，不过不是在堆上sweep实际对象，而是在marking bitmap里统计每个region被标记为活的对象有多少。这个阶段如果发现完全没有活对象的region就会将其整体回收到可分配region列表中。
****** evacuation
1. Evacuation阶段是全暂停的。它负责把一部分region里的活对象拷贝到空region里去，然后回收原本的region的空间
2. Evacuation阶段可以自由选择任意多个region来独立收集构成收集集合（collection set，简称CSet），依赖于per-region remembered set（简称RSet）实现。这是regional garbage collector的特征。
3. 在选定CSet后，evacuation其实就跟ParallelScavenge的young GC的算法类似，采用并行copying（或者叫scavenging）算法把CSet里每个region里的活对象拷贝到新的region里，整个过程完全暂停。从这个意义上说，G1的evacuation跟传统的mark-compact算法的compaction完全不同：前者会自己从根集合遍历对象图来判定对象的生死，不需要依赖global concurrent marking的结果，有就用，没有拉倒；而后者则依赖于之前的mark阶段对对象生死的判定

***** mutator
需要使用 write barrier，这两个动作都使用了logging barrier，其处理有一部分由collector一侧并发执行。
****** SATB snapshot的完整性
****** 跨region的引用记录到RSet里。

****** 
**** 分代式G1
分代式G1的正常工作流程就是在young GC与mixed GC之间视情况切换，背后定期做做全局并发标记。Initial marking默认搭在young GC上执行；当全局并发标记正在工作时，G1不会选择做mixed GC，反之如果有mixed GC正在进行中G1也不会启动initial marking。在正常工作流程中没有full GC的概念，old gen的收集全靠mixed GC来完成。如果mixed GC实在无法跟上程序分配内存的速度，导致old gen填满无法继续进行mixed GC，就会切换到G1之外的serial old GC来收集整个GC heap（注意，包括young、old、perm）。这才是真正的full GC。Full GC之所以叫full就是要收集整个堆，只选择old gen的部分region算不上full GC。进入这种状态的G1就跟-XX:+UseSerialGC的full GC一样（背后的核心代码是两者共用的）。
**** G1为什么是低延迟的？
G1只有两件事是并发执行的：
1. 全局并发标记；
2. logging write barrier的部分处理。
而“拷贝对象”（evacuation）这个很耗时的动作却不是并发而是完全暂停的。那G1为何还可以叫做低延迟的GC实现呢？

重点就在于G1虽然会mark整个堆，但并不evacuate所有有活对象的region；通过只选择收益高的少量region来evacuate，这种暂停的开销就可以（在一定范围内）可控。每次evacuate的暂停时间应该跟一般GC的young GC类似。所以G1把自己标榜为“软实时”（soft real-time）的GC。
***** 一般而言的暂停时间
但是毕竟要暂停来拷贝对象，这个暂停时间再怎么低也有限。G1的evacuation pause在几十到一百甚至两百毫秒都很正常。所以切记不要把 -XX:MaxGCPauseMillis 设得太低，不然G1跟不上目标就容易导致垃圾堆积，反而更容易引发full GC而降低性能。通常设到100ms、250ms之类的都可能是合理的。设到50ms就不太靠谱，G1可能一开始还跟得上，跑的时间一长就开始乱来了。
**** 关于CMS和G1的选型
G1需要暂停来拷贝对象，而CMS在暂停中只需要扫描（mark）对象，那算法上G1的暂停时间会比CMS短么？
1. 从堆大小来看： 其实CMS在较小的堆、合适的workload的条件下暂停时间可以很轻松的短于G1。在2011年的时候Ramki告诉我堆大小的分水岭大概在10GB～15GB左右：以下的-Xmx更适合CMS，以上的才适合试用G1。现在到了2014年，G1的实现经过一定调优，大概在6GB～8GB也可以跟CMS有一比，我之前见过有在-Xmx4g的环境里G1比CMS的暂停时间更短的案例。
2. workload：CMS最严重的暂停通常发生在remark阶段，因为它要扫描整个根集合，其中包括整个young gen。如果在CMS的并发标记阶段，mutator仍然在高速分配内存使得young gen里有很多对象的话，那remark阶段就可能会有很长时间的暂停。Young gen越大，CMS remark暂停时间就有可能越长。所以这是不适合CMS的workload。相反，如果mutator的分配速率比较温和，然后给足时间让并发的precleaning做好remark的前期工作，这样CMS就只需要较短的remark暂停，这种条件下G1的暂停时间很难低于CMS。
**** G1没有并发拷贝
要在拷贝对象的前提下实现真正的低延迟就需要做并发拷贝（concurrent compaction）。但是现在已知的实现concurrent compaction的GC算法无一例外需要使用某种形式的read barrier，例如Azul的C4和Red Hat的Shenendoah。不用read barrier的话，没办法安全的实现一边移动对象一边修正指向这些对象的引用，因为mutator也可以会并发的访问到这些引用。
why: 而G1则坚持只用write barrier不用read barrier，所以无法实现concurrent compaction。

*** ZGC

** 内存分配
+ 堆上分配 : 大多数分配至eden区，偶尔分在old
+ 栈上分配 : 原子类型的局部变量
** 内存泄漏
*** 产生原因
**** 对象定义在错误的范围 (Wrong Scope)
#+BEGIN_SRC java
  //一段代码
  class Foo{
      private string[] names;
      public void doIt(int length){
          if (names = null II names.length < length)
              names new string[length];
          populate( names);
          print(names);
      }
  }
#+END_SRC
+ 如上面这段代码，变量names声明在方法外部，假如我们只会在这个方法中使用names，且foo类生命周期非常长，那么name对象由于一直有一个引用，所以对象所占这部分内存就被偷了，改成如下代码
#+BEGIN_SRC java
  class Foo {
      public void doIt(int length) {
          String[] names = new String [length]i
              populate( names);
          print(names);
      }
  }
#+END_SRC
**** 异常( EXception)处理不当
#+BEGIN_SRC java
  //连接泄露
  Connection conn DriverManager getConnection(url, name, passwd);
  try {
      String sgl ="do a query sql";
      Preparedstatement stmt = conn. preparestatement(sql);
      Resultset rs = stmt. executequery();
      while (rs.next()){
          dosomestuff();
      }
      //主要看这里
      rs close();
      conn close();
  } catch (Exception e){
  }
#+END_SRC
+ 如果 doSomestuff()抛出异常,rg.close和cnn.close不会被调用,会导致内存泄漏和连接泄漏,改正如下
#+BEGIN_SRC java
  Preparedstatement stmt null;
  Resultset rs = null;
  try {
      string sql ="do a query sql";
      stmt conn. preparestatement(sql);
      rs stmt executequery;
      while (rs.next()){
          dosomestuff();
      }
  }catch (Exception e) {
      // handle exception
  } finally {
      //永远用finally去关闭资源,避免资源泄漏
      if (rs != null){
          rs.close();
      }
      if (stmt ! null){
          stmt. close();
      }
      conn close();
  }
#+END_SRC
**** 集合数据管理不当
** jvm write barrier
[[http://psy-lob-saw.blogspot.com/2014/10/the-jvm-write-barrier-card-marking.html][大神，G1的write barrier没看完]]
用于GC中的一些统计数据，比如RS，CS
#+begin_quote
Barriers can be implemented in either software or hardware. Software barriers involve additional instructions around load or store operations, which would typically be added by a cooperative compiler. Hardware barriers don’t require compiler support, and may be implemented on common operating systems by using memory protection.
#+end_quote
我们知道，java中，value store这个操作对原生类型和引用类型是不一样的。
*** OOP
Ordinary Object Pointer对应于JMM
*** 用途
+ 用于 card marking
+ 用于 RS和CS
*** 分代回收带来跨代引用问题
假设一个对象x只有从老年代中的对象对x的引用，name按照GC root和trace的定义，x将被回收。但明显x是不应该被回收的。card marking 用于解决这个问题。
*** card marking
java把heap分成一组card，每个card略小于内存页。jvm维护一个Map<card> dirtyCard,每当heap中的一个对象的一个引用（pointer）字段（属性）被修改时，都会有这个对象所在的card对应于Map中的一个bit被设置（为0），表示这个card中的对象引用有变化
#+begin_example
设每个card的大小为512bit，this为改变的引用关系中的发起者，则有：
CARD_TABLE [this address >> 9] = 0;
#+end_example
**** 牺牲
在代码看来，这样每当有引用类型的赋值时，都会现有一个marking card 的操作，然后才是赋值。这是必要的牺牲。
*** condition card marking
同一个card中的多个对象的引用字段发生变化时，不必每次都设置Map<card> dirtyCard中的对应标志
#+begin_example
设每个card的大小为512bit，this为改变的引用关系中的发起者，则有：
if (CARD_TABLE [this address /512] != 0) CARD_TABLE [this address >> 9] = 0; 
#+end_example
*** G1中的表现
** 对于gc的回顾
[[https://www.zhihu.com/question/53613423/answer/135743258][知乎]]
** SATB和incremental update
*** 相同点： 都是用来在并发标记阶段来保证不漏扫描活对象的方式
*** 区别
**** 前提
1. 根据三色标记算法，黑色和灰色对象都是确定存活的对象。灰色对象的集合构成了当前collector正在扫描的分界面（wavefront）。从分界面的角度看，灰色是正在分界面上，白色是在分界面之前，黑色是在分界面之后。
2. collector不会再次扫描黑对象的字段
**** 那么，什么情况下会漏掉存活的对象
两件事同时发生
1. mutator把白对象a赋值给了黑对象的某个字段
2. 白对象失去了所有能从会对象指向它的引用
黑对象持有了指向白对象的引用。根据定义，collector已经不会再去遍历黑对象的字段，所以发现不了这里还有一个活引用指向这个白对象。如果还有某个灰对象持有直接或间接引用能到达这个白对象，那就没关系；如果从灰对象出发的所有引用到这个白对象的路径都不幸被切断了，那这个白对象就要被漏扫描了。
**** 两种不同的方式
***** SATB
把marking开始时的逻辑快照里所有的活对象都看作时活的。具体做法是在write barrier里把所有旧的引用所指向的对象都变成非白的（已经黑灰就不用管，还是白的就变成灰的）
***** Incremental update
只要在write barrier里发现要有一个白对象的引用被赋值到一个黑对象的字段里，那就把这个白对象变成灰色的（例如说标记并压到marking stack上，或者是记录在类似mod-union table里）
* GC参数
** 调试常用参数
#+begin_example
  -verbose:gc
  -Xms20M
  -Xmx20M
  -Xmn10M
  -XX:+PrintGCDetails
  -XX:SurvivorRatio=8
  -XX:PretenureSizeThreshold=4194304
  -XX:+UseSerialGC
#+end_example
+ -XX:MaxTenuringThreshold=5  : 晋升年龄的最大值，也就是有可能在小于5的时候就晋升，该参数的默认值为15,CMS中默认值为6,G1中默认为15(在JVM中,该数值是由4个bit来表示的,所以最大值1111,即15). 经历了多次Gc后,存活的对象会在 From Survivor与 To Survivor之间来回存放,而这里面的一个前提则是这两个空间有足够的大小来存放这些数据,一种策略是计算每个年龄对象的大小,如果达到某个年龄后发现总大小已经大于了 Survivor空间的50%,那么这时就需要调整阈值,不能再继续等到默认的15次gc,因为这样会导致 Survivor空间不足,所以需要调整阈值,让这些存活对象尽快完成晋升。
** 定位问题
*** gclog和dump配置
1. -XX:+PrintGCDateStamps
2. -XX:+PrintGCDetails
3. -XX:+PrintGCTimeStamps

4. -Xloggc:../logs/gc_region-%t.log
5. -XX:+HeapDumpOnOutOfMemoryError
6. -XX:HeapDumpPath=/tmp/logs/dump-%t
** GC-log
含义解析样例
+ 正常gc
#+begin_example

  [ GC (Allocation Failure)[PSYoungGen: 5646K->624K(9216K)] 5646K->4728K(19456K),0.0044403 secs] [Times: user=0.03 sys=0.00, real=0.01 secs
  [ GC                   是什么GC? 是minorGC，如果是FullGC会显示FullGC
  (Allocation Failure)  GC的原因是？Allocation failure 分配内存后达到新生代设置的GC阈值，这里意为尚可分配，但是有点挤了。若压根分配不开，会直接在老年代分配
  [PSYoungGen:	本次会收使用什么垃圾收集器？ 分代parallel scavenge      
  5646K->624K(9216K)] 			     具体的，回收前新生代被使用了5646k，回收后新生代被使用624k，总的新生代可用空间9216k(配置定死的)
  5646K->4728K(19456K),		     回收前总的被使用的堆5646k，回收后总的堆被使用4728k，总堆可用大小为19456（配好的）
  0.0044403 secs] [Times: user=0.03 sys=0.00, real=0.01 secs	总共用了0.0044403秒，其中用户空间糊了0.03秒，内核空间几乎是0.00，真正运行了0.01秒
#+end_example

+ full GC
#+begin_example
  [Full GC (Ergonomics) [PSYoungGen: 608K->0K(9216K)] [ParOldGen: 5128K->5616K(10240K)] 5736K->5616K(19456K), [Metaspace: 3290K->3290K(1056768K)], 0.0057821 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
  [Full GC
  (Ergonomics)		GC本身需要的一次GC
  [PSYoungGen: 608K->0K(9216K)]	新生代回收到0了
  [ParOldGen: 5128K->5616K(10240K)] 5736K->5616K(19456K),// 回收前5128k，回收后5616k，老年代总共10240k，后面的一对数为对空间回收前后的值，堆总大小为19456k
  [Metaspace: 3290K->3290K(1056768K)], //元空间在GC前后的变化
  0.0057821 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
#+end_example

+ Full GC - another version
#+begin_example
2020-05-25T22:32:30.549+0800: 30.993: [Full GC (GCLocker Initiated GC) 2020-05-25T22:32:30.549+0800: 30.993: 
[CMS: 3086306K->3086306K(3086784K), 0.6462093 secs] 4082949K->3768837K(4083584K), // 回收前后
[Metaspace: 37917K->37917K(1083392K)], 0.6462875 secs] [Times: user=0.65 sys=0.00, real=0.64 secs]

#+end_example
** 查看虚拟机默认参数
#+BEGIN_SRC sh
  java -XX:+PrintCommandLineFlags -version
#+END_SRC

+ -XX:+UseCompressedOops : 指针膨胀时压缩
+ -XX:+UseParallelGC：新生代用Parallel scavenge 老年代用 parallel old
** -XX:UseSerialGC 
+ -XX:PretenureSizeThreshold=<字节为单位的一个数> : 老年代预备役的大小，超过这个值将直接分配在老年代

** XX:+UseStringDeduplication
+ 限制
  1. 只适用于G1
  2. 只适用于长期存活的对象，-XX:StringDeduplicationAgeThreshold=6，默认是3, 表示一个string对象经过几次GC为长期存活
  3. 可能会增加GC时间，因为有附加的清除重复字符串的工作，但影响可能是减少随后的GC频率和随后的GC过程中扫描的负担
+ -XX:+PrintStringDeduplicationStatistics查看去重信息

** ExitOnOutOfMemory and CrashOnOutOfMemory的区别
1. ExitOnOutOfMemory 相比处理oom，更倾向于重新启动一个进程实例
2. CrashOnOutOfMemory 在oom的时候生成报告文件

** ExplicitGCInvokesConcurrent
[[https://blog.csdn.net/ning0323/article/details/76505378][参考]]
G1 GC的System.gc()默认还是full GC，也就是serial old GC。只有加上 -XX:+ExplicitGCInvokesConcurrent 时G1才会用自身的并发GC来执行System.gc()——此时System.gc()的作用是强行启动一次global concurrent marking；一般情况下暂停中只会做initial marking然后就返回了，接下来的concurrent marking还是照常并发执行。

** UseCompressedClassPointers
压缩指针

** UseGCOverheadLimit
1. 1.6引入，当并行收集器花费了98%的时间却只回收了2%的内存时，会抛出java.lang.OutOfMemoryError：GC overhead limit exceeded这个异常
2. 如果需要的话，可以使用-XX:UseGCOverheadLimit来disable掉这个特性

** G1

*** G1MixedGCLiveThresholdPercent=65
如果一个region中存活的部分占整个region的65%，则这个region不会参与到mixed gc收集中
* OOM
[[https://www.cnblogs.com/intsmaze/p/9550256.html][为什么使用dump而不是报错日志]]

todo 
1. 排查内存溢出
** 生成dump文件的集中方式
1. jmapdump
2. jconsole HotSpotDiagnosticMXBean
3. jvm参数
   1) -XX:+HeapDumpOnOutOfMemoryError
   2) -XX:HeapDumpPath=/home/wangchao/brfs/ 这里配置为绝对路径，在路径下生成形如java_pid176692.hprof的dump文件，不要写死文件名
4. hprof 命令，查看cpu和内存
   1. [[http://docs.oracle.com/javase/8/docs/technotes/samples/hprof.html][参考]]
* 线程状态
[[https://www.uml-diagrams.org/java-thread-uml-state-machine-diagram-example.html][参考]]

#+DOWNLOADED: https://www.uml-diagrams.org/examples/state-machine-example-java-6-thread-states.png @ 2019-12-08 18:28:57
[[file:%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/2019-12-08_18-28-55_state-machine-example-java-6-thread-states.png]]

** waiting状态的线程被唤醒的时候进入blocked状态
#+DOWNLOADED: https://www.uml-diagrams.org/examples/state-machine-example-java-6-thread-states.png @ 2019-11-20 11:13:33
[[file:%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/2019-11-20_11-13-33_state-machine-example-java-6-thread-states.png]]
* 类加载
- 在类被首次主动使用时才会类的初始化
- 但并没有延迟加载，即类的加载在首次主动使用前就完成了，不过如果加载失败，这个错误信息要等到首次主动使用才会抛出(延迟抛出)
- 当一个类初始化的时候，它所实现的接口是不会被初始化的
- classloader去load一个类的时候不会导致类的初始化，只有用反射class.forname的时候才会初始化


** 自定义类加载器
*** 场景
1. 冲突隔离
2. 热加载
3. 代码保护
** 双亲委托机制
*** 为啥？
为了防止恶意代码，比如Object类只能有启动加载器加载，即使其它加载器想要加载Ojbect或者修改的Object类，都最终会委托给启动加载器，然后就会被发现是恶意的
*** 上下文加载器
为了破坏双亲委托机制
使得父类可以使用子类的加载器
**** 使用模式
- 获取
- 替换
- 还原
* 字节码
* 内存结构
Hotspot中方法栈和JNI方法栈是同一个
1. 堆: 线程共享,存放所有实例对象
2. 方法区: 线程共享,存储类相关信息,常量,静态变量,即时编译后的代码
3. 栈: 线程私有,局部变量表,操作栈,动态链接,方法出口,对象指针
4. 程序计数器
* 内存模型
线程本地内存和主内存的抽象关系
* 主要组件和架构
- 执行引擎
  - GC
  - JIT
* 工具
** jvisualvm
- poid 优先级
- 线程dump
- 堆dump
- Metaspace监控
** jconsole
- 线程监控可以看到线程的总等待、总阻止线程数
- 检查死锁的线程
- HotSpotDiagnosticMXBean ： 生成内存快照
** jmap
- clstat : 查看类加载器的统计数据
- heapheap :堆和gc的统计数据
- jmap -dump:file=3.dump 19076 : 生成内存快照
- -histo : 内存直方图
** jstat
- gc gc统计信息
  - MC : current metaspace capacity  （KB）
  - MU : metaspace Utillization 已用空间
- jstat -gc -t <pid> 1s : 这个命令有歧义
- 可以用来观察内存使用变化情况
*** in action 
**** jstat -gc pid 500 100
可以看出新生代增长很快,老年代也涨的很快
#+begin_example
  S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   
   0.0    0.0    0.0    0.0   3964928.0 458752.0 2326528.0   490449.6  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 524288.0 2326528.0   524536.3  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 589824.0 2326528.0   541579.6  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 688128.0 2326528.0   575666.3  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 753664.0 2326528.0   609753.0  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 819200.0 2326528.0   626796.4  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 884736.0 2326528.0   660883.1  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 983040.0 2326528.0   694969.8  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1081344.0 2326528.0   729056.5  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1114112.0 2326528.0   746099.8  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1212416.0 2326528.0   780186.5  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1310720.0 2326528.0   814273.2  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1441792.0 2326528.0   848360.0  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1507328.0 2326528.0   865403.3  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1638400.0 2326528.0   899490.0  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1736704.0 2326528.0   916533.4  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1802240.0 2326528.0   950620.1  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1900544.0 2326528.0   984706.8  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 1998848.0 2326528.0  1018793.5  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2064384.0 2326528.0  1052880.2  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2162688.0 2326528.0  1086966.9  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2228224.0 2326528.0  1104010.2  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2293760.0 2326528.0  1138096.9  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2392064.0 2326528.0  1172183.6  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2490368.0 2326528.0  1206270.3  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2523136.0 2326528.0  1223313.7  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0    0.0    0.0    0.0   3964928.0 2621440.0 2326528.0  1257400.4  75724.0 72280.4 9164.0 8477.9   1595  125.146   2      1.795  126.941
   0.0   32768.0  0.0   32768.0 3932160.0 32768.0  2326528.0   356682.9  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 163840.0 2326528.0   358001.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 262144.0 2326528.0   375045.0  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 327680.0 2326528.0   409131.7  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 425984.0 2326528.0   443218.4  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 491520.0 2326528.0   477305.1  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 589824.0 2326528.0   511391.8  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 655360.0 2326528.0   528435.1  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 720896.0 2326528.0   562521.9  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 819200.0 2326528.0   596608.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 917504.0 2326528.0   630695.3  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 983040.0 2326528.0   664782.0  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1081344.0 2326528.0   698868.7  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1114112.0 2326528.0   715912.0  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1212416.0 2326528.0   749998.7  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1310720.0 2326528.0   784085.4  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1409024.0 2326528.0   818172.1  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1474560.0 2326528.0   852258.8  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1572864.0 2326528.0   886345.5  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1638400.0 2326528.0   903388.9  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1736704.0 2326528.0   937475.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1802240.0 2326528.0   971562.3  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1900544.0 2326528.0  1005649.0  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 1966080.0 2326528.0  1039735.7  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2064384.0 2326528.0  1073822.4  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2129920.0 2326528.0  1090865.8  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2228224.0 2326528.0  1124952.5  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2293760.0 2326528.0  1159039.2  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2392064.0 2326528.0  1193125.9  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2490368.0 2326528.0  1227212.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2555904.0 2326528.0  1261299.3  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2621440.0 2326528.0  1278342.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2719744.0 2326528.0  1312429.3  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2818048.0 2326528.0  1346516.0  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2883584.0 2326528.0  1380602.7  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 2949120.0 2326528.0  1397646.1  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3047424.0 2326528.0  1431732.8  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3080192.0 2326528.0  1448776.1  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3178496.0 2326528.0  1482862.8  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3244032.0 2326528.0  1516949.5  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3309568.0 2326528.0  1533992.9  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0   32768.0  0.0   32768.0 3932160.0 3407872.0 2326528.0  1568079.6  75724.0 72280.4 9164.0 8477.9   1596  125.178   2      1.795  126.973
   0.0    0.0    0.0    0.0   3964928.0 98304.0  2326528.0   371256.6  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 196608.0 2326528.0   405343.3  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 294912.0 2326528.0   422386.7  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 425984.0 2326528.0   456473.4  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 524288.0 2326528.0   490560.1  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 622592.0 2326528.0   507603.4  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 753664.0 2326528.0   541690.1  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 819200.0 2326528.0   575776.8  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 917504.0 2326528.0   609863.5  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 983040.0 2326528.0   643950.2  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1048576.0 2326528.0   660993.6  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1146880.0 2326528.0   695080.3  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1212416.0 2326528.0   729167.0  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1310720.0 2326528.0   763253.7  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1409024.0 2326528.0   797340.4  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1441792.0 2326528.0   814383.8  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1540096.0 2326528.0   848470.5  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1638400.0 2326528.0   882557.2  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1736704.0 2326528.0   916643.9  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1802240.0 2326528.0   950730.6  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1900544.0 2326528.0   984817.3  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 1966080.0 2326528.0  1001860.6  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2031616.0 2326528.0  1035947.3  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2129920.0 2326528.0  1070034.0  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2228224.0 2326528.0  1104120.7  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2293760.0 2326528.0  1138207.4  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2359296.0 2326528.0  1155250.8  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
   0.0    0.0    0.0    0.0   3964928.0 2457600.0 2326528.0  1189337.5  75724.0 72280.4 9164.0 8477.9   1597  125.200   2      1.795  126.995
#+end_example


** jcmd (1.7新增的)
- jcmd <pid> help ： 看一下可以对这个进程做什么
- jcmd <pid> help <具体命令> : 具体命令的帮助
- jcmd <pid> VM.flags : 查看jvm启动参数
- jcmd <pid> PerfCounter.print : 统计jvm性能
- jcmd <pid> VM.uptime : 这个jvm启动多长时间了
- jcmd <pid> GC.class_histogram : 类的统计信息  可以用head查看前几行
- jcmd <pid> Thread.print : 线程堆栈信息，grep deadlock 看有没有死锁及死锁的详细信息
- jcmd <pid> GC.heap_dump <目标文件> : 导出dump文件，然后用jvisualvm装载(打开gui>菜单栏>装入文件)文件分析，heap dump会导致程序暂停一下
- jcmd <pid> VM.system_properties : 查看jvm的信息，也就是 ps -ef 输出的那一大坨信息
- 获得命令行参数
- 获得jvm版本信息
** jstack
与jcmd pid Thread.print差不多，但jstack是专门获得线程堆栈信息的
- jstack <pid>
** jmc(java mission control)
- 与jcmd差不多，但是是实时的
- 可以jcmd生成JFR(java fligh recorder:飞行记录器)文件
** jhat
**** 可以转储dump文件
**** 可以分析dump文件(没有图形界面的时候用)
1. 可以按条件查询，比如查询某个class的所有实例

** heapHore
** gceasy
** top
查看cpu到底在干什么
1. 使用top命令查找CPU使用率最高的进程

2. top -H -p pid 找到CPU使用率最高的线程(-H 线程模式)

3. printf “%x\n” tid 把线程ID输出为16进制(java 中线程nid(16进制)-->linux 中tid(10进制))

4. jstack pid | less 从中模式匹配nid，查看对应代码
** gc日志分析
GCViewer
*** 使用步骤
1. git clone git@github.com:chewiebug/GCViewer.git
2. mvn clean package
3. java -jar gcviewer-xxx.jar
4. 装入log
** mat
*** 分析命令
- org.eclipse.mat.api:suspects 找到可以的内存泄漏
#+BEGIN_SRC sh
  ./ParseHeapDump.sh ~/brfs/dumpdir/dump-data org.eclipse.mat.api:suspects org.eclipse.mat.api:overview org.eclipse.mat.api:top_components
#+END_SRC
* 字符串常量池
* to read
[[https://cloud.tencent.com/developer/article/1451049][干货]]
[[https://www.ps.uni-saarland.de/courses/gc-ws01/slides/generational_gc.pdf][分代回收]]
[[http://users.cecs.anu.edu.au/~steveb/pubs/papers/wb-ismm-2004.pdf][barries]]
