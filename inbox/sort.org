* 基于比较的排序算法
** 冒泡
*** 时间复杂度最坏为O(n2)
*** 稳定
*** 优化方法
1. 外层循环加全局有序判断，这样最好情况为O(n)
2. 内层循环利用局部有序，记录最后发生交换的位置，用来更新外层循环上限和内循环上限
*** 应用场景布吉岛
** 选择排序
** 插入排序
*** 时间复杂度
最好O(n)
平均O(n2)
最坏O(n2)

*** 稳定
*** 使用场景
1. jdk中的Arrays.sort()在排序长度小于7的时候使用直接插入
** 归并排序
*** 时间复杂度
O(nlogn)
*** 稳定
*** 优化手段
1. 合并阶段判有序
2. 当合并的两部分中一部分用尽，另一部分直接放入
** 快速排序
*** 三大缺点
1. 最坏O(n2)
2. 平均性能O(nlogn) [[https://www.bilibili.com/video/av49361421/?p=449][证明]]
3. 不稳定
4. 不适应（原始数据越有序，快排越慢）
*** 轴点的选择
1. 不同的轴点选取算法只能降低最坏情况的可能性，而不能杜绝最坏情况
*** 适用算法
1. k-selection
2. 选取中位数
*** 引申问题
1. 选取众数
2. 选取第K大元素
3. 中位数 
*** inbox
- 相比于归并排序看中“合”，快速排序看中“分”
- 快排的可以看做将所有待排元素转换为轴点的过程
** 堆排序
** 希尔排序
** 桶排序
复杂度 : \Omicron(n)
** 统计排序
** 基数排序
* todo
** TODO 轴点的选择<2018-09-18 二 15:42>
:LOGBOOK:
CLOCK: [2018-09-18 二 16:33]--[2018-09-18 二 16:58] =>  0:25
:END:
方案[1/3]
- [X] 打乱数组
- [ ] 随机选数
- [ ] 三元素取中 
- State "TODO"       from              [2018-09-18 二 15:42]
** 双轴快速排序
** 中位数和众数的选择
** cpu分支预测
** 内存缓存
** 归并的优化
+ 自底向上的迭代实现
** 堆排序实际使用效率不高的原因
* 稳定性的意义
对于基本数据类型无意义
对对象类型保证有序
