#+title: rocksDB
* rocksDB的历史
** 大数据分析所涉及到的点
  + 大范围顺序读
  + 两个或多个数据集的join
  + 很少量的更新
** 机械磁盘（spinning disk）的年代
通过不断优化，hbase的查询仅仅是MySql的两倍，IOPs是3倍
** 闪存(Flash storage)的出现
2012年的hbase和hdsf因为一些软件瓶颈，[[http://hadoopblog.blogspot.com/2012/05/hadoop-and-solid-state-drives.html][detail]]，无法很好的利用闪存。因而一款面向告诉闪存的KV存储引擎呼之欲出
** 为什么我们需要一个嵌入式（Embedded）数据库？
+ 设：我们对机械磁盘的一次读写耗时10 milliseconds，对闪存的一次读写耗时100 microseconds。两者差100倍，两台机器间的网络延迟为50 microseconds
+ 则 : 机械磁盘的时代，一次cs架构的数据存取只比本地存取多负担0.05ms/10ms=0.5%
+ 而 : 闪存出现后，一次cs架构的数据存取比本地存取多负担50microseconds/100microseconds=50%
+ 所以：我们需要一个嵌入式数据库[[http://en.wikipedia.org/wiki/Embedded_database][detail]]，因为它在闪存cs架构下依然会有很低的延迟
** 向闪存更新数据block总是会存在写放大(write-endurance)
** levelDB有什么不足?
+ 必须fit in OS page cache
+ 写放大严重
+ 跟不上日趋快速的存储硬件
** 展望rocksDB
1. 嵌入式KV存储，支持点查和范围查
2. 更适应于告诉存储硬件
3. 完整的数据库服务支持
4. 随着cpu和IOPs的线性成长
5. rocksDB不是一个分布式数据库，由上层应用实现replication、fault-tolerance、sharding
** RocksDB架构
todo
* using rocksDB 
1. use shell
** 在mac上安装使用rocksdb
安装
#+BEGIN_SRC sh
  brew install rocksdb
# 安装完的可执行文件
-r-xr-xr-x   1 wangchao  staff  5031508 Mar  5 23:20 rocksdb_dump
-r-xr-xr-x   1 wangchao  staff  5029696 Mar  5 23:20 rocksdb_ldb
-r-xr-xr-x   1 wangchao  staff  5075428 Mar  5 23:20 rocksdb_repl_stress
-r-xr-xr-x   1 wangchao  staff  5082536 Mar  5 23:20 rocksdb_sanity_test
-r-xr-xr-x   1 wangchao  staff  5029696 Mar  5 23:20 rocksdb_sst_dump
-r-xr-xr-x   1 wangchao  staff  5280732 Mar  5 23:20 rocksdb_stress
-r-xr-xr-x   1 wangchao  staff  5031508 Mar  5 23:20 rocksdb_undump
-r-xr-xr-x   1 wangchao  staff  5080924 Mar  5 23:20 rocksdb_write_stress
  pwd
/usr/local/Cellar/rocksdb/6.6.4/bin
#+END_SRC
** 在mac上编译rocksdb
#+BEGIN_SRC sh
  git clone
  make all
  ./db_bench fillseq --compression_type=none

./db_bench --benchmarks="readrandom" --use_existing_db --compression_type=none --statistics
#+END_SRC
* rocksdb 备份
* rocksdb 读写缓存管理 Write Buffer Manager
WriteBufferManager可以用来控制多列族和多个DB实例所共享的写缓存。在使用方式上分为两种
1. 单独限制总的写缓存 WriteBufferManager(size)
2. 在blockCache中计算Memtable消耗的写缓存，这样读写缓存可以限制在一个阈值之下,WriteBufferManager(size, cache)

一个WriteBufferManager实例可以传给column families 或者整个DB
** 第一种：限制总的写缓存
创建WriteBufferManager时需要传入一个内存限制，rocksdb会尝试将总的写缓存限制在这个阈值之下

在5.6之后，flush一个cf的触发条件有如下两种
1. 如果所有的mutable memtable(正在插入数据的memtable)的size超过阈值的90%
2. 如果总的内存超过限制，而mutable memtable size超过限制的50%，才会采取更为激进的flush

5.6之前总内存消耗在arena区中的计算是实际使用的
5.6之后总内存消耗在arena区中的计算是分配的，即使尚未使用
** 第二种：在block cache 中计算写缓存（memtable占用的内存）
如果要完整控制整个rocksdb的内存占用，建议WriteBufferManager(size, cache) 这种方式。
同时打开cache_index_and_filter_blocks = true。
这样，整个memtable, datablock, index&filter block都能被blockcache的容量限制

从5.6开始，用户可以设置rocksdb在blockcache中计算memtables的内存消耗，如此不管写缓存总限制设置与否，都能够对rokcsdb整体内存做限制
总的来说，block cache用于读的实际占用偏小，所以可以写缓存和index、filter都放进来
